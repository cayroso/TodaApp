(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendor.microsoft"],{

/***/ "++1n":
/*!******************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/IHubProtocol.js ***!
  \******************************************************************/
/*! exports provided: MessageType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MessageType\", function() { return MessageType; });\n// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\n\n/** Defines the type of a Hub Message. */\nvar MessageType;\n\n(function (MessageType) {\n  /** Indicates the message is an Invocation message and implements the {@link @microsoft/signalr.InvocationMessage} interface. */\n  MessageType[MessageType[\"Invocation\"] = 1] = \"Invocation\";\n  /** Indicates the message is a StreamItem message and implements the {@link @microsoft/signalr.StreamItemMessage} interface. */\n\n  MessageType[MessageType[\"StreamItem\"] = 2] = \"StreamItem\";\n  /** Indicates the message is a Completion message and implements the {@link @microsoft/signalr.CompletionMessage} interface. */\n\n  MessageType[MessageType[\"Completion\"] = 3] = \"Completion\";\n  /** Indicates the message is a Stream Invocation message and implements the {@link @microsoft/signalr.StreamInvocationMessage} interface. */\n\n  MessageType[MessageType[\"StreamInvocation\"] = 4] = \"StreamInvocation\";\n  /** Indicates the message is a Cancel Invocation message and implements the {@link @microsoft/signalr.CancelInvocationMessage} interface. */\n\n  MessageType[MessageType[\"CancelInvocation\"] = 5] = \"CancelInvocation\";\n  /** Indicates the message is a Ping message and implements the {@link @microsoft/signalr.PingMessage} interface. */\n\n  MessageType[MessageType[\"Ping\"] = 6] = \"Ping\";\n  /** Indicates the message is a Close message and implements the {@link @microsoft/signalr.CloseMessage} interface. */\n\n  MessageType[MessageType[\"Close\"] = 7] = \"Close\";\n})(MessageType || (MessageType = {}));\n\n//# sourceURL=webpack:///./node_modules/@microsoft/signalr/dist/esm/IHubProtocol.js?");

/***/ }),

/***/ "1/4N":
/*!*********************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/FetchHttpClient.js ***!
  \*********************************************************************/
/*! exports provided: FetchHttpClient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FetchHttpClient\", function() { return FetchHttpClient; });\n/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Errors */ \"9BRb\");\n/* harmony import */ var _HttpClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HttpClient */ \"Rlqr\");\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ILogger */ \"M+GD\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Utils */ \"ftFU\");\n// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\nvar __extends = undefined && undefined.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = undefined && undefined.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n  }\n\n  return t;\n};\n\nvar __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = undefined && undefined.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\n\n\n\n\n\nvar FetchHttpClient =\n/** @class */\nfunction (_super) {\n  __extends(FetchHttpClient, _super);\n\n  function FetchHttpClient(logger) {\n    var _this = _super.call(this) || this;\n\n    _this.logger = logger;\n\n    if (typeof fetch === \"undefined\") {\n      // In order to ignore the dynamic require in webpack builds we need to do this magic\n      // @ts-ignore: TS doesn't know about these names\n      var requireFunc =  true ? require : undefined; // Cookies aren't automatically handled in Node so we need to add a CookieJar to preserve cookies across requests\n\n      _this.jar = new (requireFunc(\"tough-cookie\").CookieJar)();\n      _this.fetchType = requireFunc(\"node-fetch\"); // node-fetch doesn't have a nice API for getting and setting cookies\n      // fetch-cookie will wrap a fetch implementation with a default CookieJar or a provided one\n\n      _this.fetchType = requireFunc(\"fetch-cookie\")(_this.fetchType, _this.jar); // Node needs EventListener methods on AbortController which our custom polyfill doesn't provide\n\n      _this.abortControllerType = requireFunc(\"abort-controller\");\n    } else {\n      _this.fetchType = fetch.bind(self);\n      _this.abortControllerType = AbortController;\n    }\n\n    return _this;\n  }\n  /** @inheritDoc */\n\n\n  FetchHttpClient.prototype.send = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var abortController, error, timeoutId, msTimeout, response, e_1, content, payload;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // Check that abort was not signaled before calling send\n            if (request.abortSignal && request.abortSignal.aborted) {\n              throw new _Errors__WEBPACK_IMPORTED_MODULE_0__[\"AbortError\"]();\n            }\n\n            if (!request.method) {\n              throw new Error(\"No method defined.\");\n            }\n\n            if (!request.url) {\n              throw new Error(\"No url defined.\");\n            }\n\n            abortController = new this.abortControllerType(); // Hook our abortSignal into the abort controller\n\n            if (request.abortSignal) {\n              request.abortSignal.onabort = function () {\n                abortController.abort();\n                error = new _Errors__WEBPACK_IMPORTED_MODULE_0__[\"AbortError\"]();\n              };\n            }\n\n            timeoutId = null;\n\n            if (request.timeout) {\n              msTimeout = request.timeout;\n              timeoutId = setTimeout(function () {\n                abortController.abort();\n\n                _this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Warning, \"Timeout from HTTP request.\");\n\n                error = new _Errors__WEBPACK_IMPORTED_MODULE_0__[\"TimeoutError\"]();\n              }, msTimeout);\n            }\n\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3, 4, 5]);\n\n            return [4\n            /*yield*/\n            , this.fetchType(request.url, {\n              body: request.content,\n              cache: \"no-cache\",\n              credentials: request.withCredentials === true ? \"include\" : \"same-origin\",\n              headers: __assign({\n                \"Content-Type\": \"text/plain;charset=UTF-8\",\n                \"X-Requested-With\": \"XMLHttpRequest\"\n              }, request.headers),\n              method: request.method,\n              mode: \"cors\",\n              redirect: \"manual\",\n              signal: abortController.signal\n            })];\n\n          case 2:\n            response = _a.sent();\n            return [3\n            /*break*/\n            , 5];\n\n          case 3:\n            e_1 = _a.sent();\n\n            if (error) {\n              throw error;\n            }\n\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Warning, \"Error from HTTP request. \" + e_1 + \".\");\n            throw e_1;\n\n          case 4:\n            if (timeoutId) {\n              clearTimeout(timeoutId);\n            }\n\n            if (request.abortSignal) {\n              request.abortSignal.onabort = null;\n            }\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 5:\n            if (!response.ok) {\n              throw new _Errors__WEBPACK_IMPORTED_MODULE_0__[\"HttpError\"](response.statusText, response.status);\n            }\n\n            content = deserializeContent(response, request.responseType);\n            return [4\n            /*yield*/\n            , content];\n\n          case 6:\n            payload = _a.sent();\n            return [2\n            /*return*/\n            , new _HttpClient__WEBPACK_IMPORTED_MODULE_1__[\"HttpResponse\"](response.status, response.statusText, payload)];\n        }\n      });\n    });\n  };\n\n  FetchHttpClient.prototype.getCookieString = function (url) {\n    var cookies = \"\";\n\n    if (_Utils__WEBPACK_IMPORTED_MODULE_3__[\"Platform\"].isNode && this.jar) {\n      // @ts-ignore: unused variable\n      this.jar.getCookies(url, function (e, c) {\n        return cookies = c.join(\"; \");\n      });\n    }\n\n    return cookies;\n  };\n\n  return FetchHttpClient;\n}(_HttpClient__WEBPACK_IMPORTED_MODULE_1__[\"HttpClient\"]);\n\n\n\nfunction deserializeContent(response, responseType) {\n  var content;\n\n  switch (responseType) {\n    case \"arraybuffer\":\n      content = response.arrayBuffer();\n      break;\n\n    case \"text\":\n      content = response.text();\n      break;\n\n    case \"blob\":\n    case \"document\":\n    case \"json\":\n      throw new Error(responseType + \" is not supported.\");\n\n    default:\n      content = response.text();\n      break;\n  }\n\n  return content;\n}\n\n//# sourceURL=webpack:///./node_modules/@microsoft/signalr/dist/esm/FetchHttpClient.js?");

/***/ }),

/***/ "2lgH":
/*!********************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/HttpConnection.js ***!
  \********************************************************************/
/*! exports provided: HttpConnection, TransportSendQueue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HttpConnection\", function() { return HttpConnection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TransportSendQueue\", function() { return TransportSendQueue; });\n/* harmony import */ var _DefaultHttpClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultHttpClient */ \"Ysxs\");\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ILogger */ \"M+GD\");\n/* harmony import */ var _ITransport__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ITransport */ \"qFkC\");\n/* harmony import */ var _LongPollingTransport__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LongPollingTransport */ \"C/dI\");\n/* harmony import */ var _ServerSentEventsTransport__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ServerSentEventsTransport */ \"qIXe\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Utils */ \"ftFU\");\n/* harmony import */ var _WebSocketTransport__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./WebSocketTransport */ \"6xqK\");\n// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\nvar __assign = undefined && undefined.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n  }\n\n  return t;\n};\n\nvar __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = undefined && undefined.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\n\n\n\n\n\n\n\nvar MAX_REDIRECTS = 100;\n/** @private */\n\nvar HttpConnection =\n/** @class */\nfunction () {\n  function HttpConnection(url, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.features = {};\n    this.negotiateVersion = 1;\n    _Utils__WEBPACK_IMPORTED_MODULE_5__[\"Arg\"].isRequired(url, \"url\");\n    this.logger = Object(_Utils__WEBPACK_IMPORTED_MODULE_5__[\"createLogger\"])(options.logger);\n    this.baseUrl = this.resolveUrl(url);\n    options = options || {};\n    options.logMessageContent = options.logMessageContent === undefined ? false : options.logMessageContent;\n\n    if (typeof options.withCredentials === \"boolean\" || options.withCredentials === undefined) {\n      options.withCredentials = options.withCredentials === undefined ? true : options.withCredentials;\n    } else {\n      throw new Error(\"withCredentials option was not a 'boolean' or 'undefined' value\");\n    }\n\n    var webSocketModule = null;\n    var eventSourceModule = null;\n\n    if (_Utils__WEBPACK_IMPORTED_MODULE_5__[\"Platform\"].isNode && \"function\" !== \"undefined\") {\n      // In order to ignore the dynamic require in webpack builds we need to do this magic\n      // @ts-ignore: TS doesn't know about these names\n      var requireFunc =  true ? require : undefined;\n      webSocketModule = requireFunc(\"ws\");\n      eventSourceModule = requireFunc(\"eventsource\");\n    }\n\n    if (!_Utils__WEBPACK_IMPORTED_MODULE_5__[\"Platform\"].isNode && typeof WebSocket !== \"undefined\" && !options.WebSocket) {\n      options.WebSocket = WebSocket;\n    } else if (_Utils__WEBPACK_IMPORTED_MODULE_5__[\"Platform\"].isNode && !options.WebSocket) {\n      if (webSocketModule) {\n        options.WebSocket = webSocketModule;\n      }\n    }\n\n    if (!_Utils__WEBPACK_IMPORTED_MODULE_5__[\"Platform\"].isNode && typeof EventSource !== \"undefined\" && !options.EventSource) {\n      options.EventSource = EventSource;\n    } else if (_Utils__WEBPACK_IMPORTED_MODULE_5__[\"Platform\"].isNode && !options.EventSource) {\n      if (typeof eventSourceModule !== \"undefined\") {\n        options.EventSource = eventSourceModule;\n      }\n    }\n\n    this.httpClient = options.httpClient || new _DefaultHttpClient__WEBPACK_IMPORTED_MODULE_0__[\"DefaultHttpClient\"](this.logger);\n    this.connectionState = \"Disconnected\"\n    /* Disconnected */\n    ;\n    this.connectionStarted = false;\n    this.options = options;\n    this.onreceive = null;\n    this.onclose = null;\n  }\n\n  HttpConnection.prototype.start = function (transferFormat) {\n    return __awaiter(this, void 0, void 0, function () {\n      var message, message;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            transferFormat = transferFormat || _ITransport__WEBPACK_IMPORTED_MODULE_2__[\"TransferFormat\"].Binary;\n            _Utils__WEBPACK_IMPORTED_MODULE_5__[\"Arg\"].isIn(transferFormat, _ITransport__WEBPACK_IMPORTED_MODULE_2__[\"TransferFormat\"], \"transferFormat\");\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Debug, \"Starting connection with transfer format '\" + _ITransport__WEBPACK_IMPORTED_MODULE_2__[\"TransferFormat\"][transferFormat] + \"'.\");\n\n            if (this.connectionState !== \"Disconnected\"\n            /* Disconnected */\n            ) {\n                return [2\n                /*return*/\n                , Promise.reject(new Error(\"Cannot start an HttpConnection that is not in the 'Disconnected' state.\"))];\n              }\n\n            this.connectionState = \"Connecting\"\n            /* Connecting */\n            ;\n            this.startInternalPromise = this.startInternal(transferFormat);\n            return [4\n            /*yield*/\n            , this.startInternalPromise];\n\n          case 1:\n            _a.sent();\n\n            if (!(this.connectionState === \"Disconnecting\"\n            /* Disconnecting */\n            )) return [3\n              /*break*/\n              , 3];\n            message = \"Failed to start the HttpConnection before stop() was called.\";\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Error, message); // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.\n\n            return [4\n            /*yield*/\n            , this.stopPromise];\n\n          case 2:\n            // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.\n            _a.sent();\n\n            return [2\n            /*return*/\n            , Promise.reject(new Error(message))];\n\n          case 3:\n            if (this.connectionState !== \"Connected\"\n            /* Connected */\n            ) {\n                message = \"HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!\";\n                this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Error, message);\n                return [2\n                /*return*/\n                , Promise.reject(new Error(message))];\n              }\n\n            _a.label = 4;\n\n          case 4:\n            this.connectionStarted = true;\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  HttpConnection.prototype.send = function (data) {\n    if (this.connectionState !== \"Connected\"\n    /* Connected */\n    ) {\n        return Promise.reject(new Error(\"Cannot send data if the connection is not in the 'Connected' State.\"));\n      }\n\n    if (!this.sendQueue) {\n      this.sendQueue = new TransportSendQueue(this.transport);\n    } // Transport will not be null if state is connected\n\n\n    return this.sendQueue.send(data);\n  };\n\n  HttpConnection.prototype.stop = function (error) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.connectionState === \"Disconnected\"\n            /* Disconnected */\n            ) {\n                this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Debug, \"Call to HttpConnection.stop(\" + error + \") ignored because the connection is already in the disconnected state.\");\n                return [2\n                /*return*/\n                , Promise.resolve()];\n              }\n\n            if (this.connectionState === \"Disconnecting\"\n            /* Disconnecting */\n            ) {\n                this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Debug, \"Call to HttpConnection.stop(\" + error + \") ignored because the connection is already in the disconnecting state.\");\n                return [2\n                /*return*/\n                , this.stopPromise];\n              }\n\n            this.connectionState = \"Disconnecting\"\n            /* Disconnecting */\n            ;\n            this.stopPromise = new Promise(function (resolve) {\n              // Don't complete stop() until stopConnection() completes.\n              _this.stopPromiseResolver = resolve;\n            }); // stopInternal should never throw so just observe it.\n\n            return [4\n            /*yield*/\n            , this.stopInternal(error)];\n\n          case 1:\n            // stopInternal should never throw so just observe it.\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , this.stopPromise];\n\n          case 2:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  HttpConnection.prototype.stopInternal = function (error) {\n    return __awaiter(this, void 0, void 0, function () {\n      var e_1, e_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // Set error as soon as possible otherwise there is a race between\n            // the transport closing and providing an error and the error from a close message\n            // We would prefer the close message error.\n            this.stopError = error;\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.startInternalPromise];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            e_1 = _a.sent();\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            if (!this.transport) return [3\n            /*break*/\n            , 9];\n            _a.label = 5;\n\n          case 5:\n            _a.trys.push([5, 7,, 8]);\n\n            return [4\n            /*yield*/\n            , this.transport.stop()];\n\n          case 6:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 8];\n\n          case 7:\n            e_2 = _a.sent();\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Error, \"HttpConnection.transport.stop() threw error '\" + e_2 + \"'.\");\n            this.stopConnection();\n            return [3\n            /*break*/\n            , 8];\n\n          case 8:\n            this.transport = undefined;\n            return [3\n            /*break*/\n            , 10];\n\n          case 9:\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Debug, \"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.\");\n            this.stopConnection();\n            _a.label = 10;\n\n          case 10:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  HttpConnection.prototype.startInternal = function (transferFormat) {\n    return __awaiter(this, void 0, void 0, function () {\n      var url, negotiateResponse, redirects, _loop_1, this_1, e_3;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            url = this.baseUrl;\n            this.accessTokenFactory = this.options.accessTokenFactory;\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 12,, 13]);\n\n            if (!this.options.skipNegotiation) return [3\n            /*break*/\n            , 5];\n            if (!(this.options.transport === _ITransport__WEBPACK_IMPORTED_MODULE_2__[\"HttpTransportType\"].WebSockets)) return [3\n            /*break*/\n            , 3]; // No need to add a connection ID in this case\n\n            this.transport = this.constructTransport(_ITransport__WEBPACK_IMPORTED_MODULE_2__[\"HttpTransportType\"].WebSockets); // We should just call connect directly in this case.\n            // No fallback or negotiate in this case.\n\n            return [4\n            /*yield*/\n            , this.startTransport(url, transferFormat)];\n\n          case 2:\n            // We should just call connect directly in this case.\n            // No fallback or negotiate in this case.\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            throw new Error(\"Negotiation can only be skipped when using the WebSocket transport directly.\");\n\n          case 4:\n            return [3\n            /*break*/\n            , 11];\n\n          case 5:\n            negotiateResponse = null;\n            redirects = 0;\n\n            _loop_1 = function () {\n              var accessToken_1;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    return [4\n                    /*yield*/\n                    , this_1.getNegotiationResponse(url)];\n\n                  case 1:\n                    negotiateResponse = _a.sent(); // the user tries to stop the connection when it is being started\n\n                    if (this_1.connectionState === \"Disconnecting\"\n                    /* Disconnecting */\n                    || this_1.connectionState === \"Disconnected\"\n                    /* Disconnected */\n                    ) {\n                        throw new Error(\"The connection was stopped during negotiation.\");\n                      }\n\n                    if (negotiateResponse.error) {\n                      throw new Error(negotiateResponse.error);\n                    }\n\n                    if (negotiateResponse.ProtocolVersion) {\n                      throw new Error(\"Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.\");\n                    }\n\n                    if (negotiateResponse.url) {\n                      url = negotiateResponse.url;\n                    }\n\n                    if (negotiateResponse.accessToken) {\n                      accessToken_1 = negotiateResponse.accessToken;\n\n                      this_1.accessTokenFactory = function () {\n                        return accessToken_1;\n                      };\n                    }\n\n                    redirects++;\n                    return [2\n                    /*return*/\n                    ];\n                }\n              });\n            };\n\n            this_1 = this;\n            _a.label = 6;\n\n          case 6:\n            return [5\n            /*yield**/\n            , _loop_1()];\n\n          case 7:\n            _a.sent();\n\n            _a.label = 8;\n\n          case 8:\n            if (negotiateResponse.url && redirects < MAX_REDIRECTS) return [3\n            /*break*/\n            , 6];\n            _a.label = 9;\n\n          case 9:\n            if (redirects === MAX_REDIRECTS && negotiateResponse.url) {\n              throw new Error(\"Negotiate redirection limit exceeded.\");\n            }\n\n            return [4\n            /*yield*/\n            , this.createTransport(url, this.options.transport, negotiateResponse, transferFormat)];\n\n          case 10:\n            _a.sent();\n\n            _a.label = 11;\n\n          case 11:\n            if (this.transport instanceof _LongPollingTransport__WEBPACK_IMPORTED_MODULE_3__[\"LongPollingTransport\"]) {\n              this.features.inherentKeepAlive = true;\n            }\n\n            if (this.connectionState === \"Connecting\"\n            /* Connecting */\n            ) {\n                // Ensure the connection transitions to the connected state prior to completing this.startInternalPromise.\n                // start() will handle the case when stop was called and startInternal exits still in the disconnecting state.\n                this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Debug, \"The HttpConnection connected successfully.\");\n                this.connectionState = \"Connected\"\n                /* Connected */\n                ;\n              }\n\n            return [3\n            /*break*/\n            , 13];\n\n          case 12:\n            e_3 = _a.sent();\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Error, \"Failed to start the connection: \" + e_3);\n            this.connectionState = \"Disconnected\"\n            /* Disconnected */\n            ;\n            this.transport = undefined;\n            return [2\n            /*return*/\n            , Promise.reject(e_3)];\n\n          case 13:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  HttpConnection.prototype.getNegotiationResponse = function (url) {\n    return __awaiter(this, void 0, void 0, function () {\n      var headers, token, _a, name, value, negotiateUrl, response, negotiateResponse, e_4;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            headers = {};\n            if (!this.accessTokenFactory) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.accessTokenFactory()];\n\n          case 1:\n            token = _b.sent();\n\n            if (token) {\n              headers[\"Authorization\"] = \"Bearer \" + token;\n            }\n\n            _b.label = 2;\n\n          case 2:\n            _a = Object(_Utils__WEBPACK_IMPORTED_MODULE_5__[\"getUserAgentHeader\"])(), name = _a[0], value = _a[1];\n            headers[name] = value;\n            negotiateUrl = this.resolveNegotiateUrl(url);\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Debug, \"Sending negotiation request: \" + negotiateUrl + \".\");\n            _b.label = 3;\n\n          case 3:\n            _b.trys.push([3, 5,, 6]);\n\n            return [4\n            /*yield*/\n            , this.httpClient.post(negotiateUrl, {\n              content: \"\",\n              headers: __assign({}, headers, this.options.headers),\n              withCredentials: this.options.withCredentials\n            })];\n\n          case 4:\n            response = _b.sent();\n\n            if (response.statusCode !== 200) {\n              return [2\n              /*return*/\n              , Promise.reject(new Error(\"Unexpected status code returned from negotiate '\" + response.statusCode + \"'\"))];\n            }\n\n            negotiateResponse = JSON.parse(response.content);\n\n            if (!negotiateResponse.negotiateVersion || negotiateResponse.negotiateVersion < 1) {\n              // Negotiate version 0 doesn't use connectionToken\n              // So we set it equal to connectionId so all our logic can use connectionToken without being aware of the negotiate version\n              negotiateResponse.connectionToken = negotiateResponse.connectionId;\n            }\n\n            return [2\n            /*return*/\n            , negotiateResponse];\n\n          case 5:\n            e_4 = _b.sent();\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Error, \"Failed to complete negotiation with the server: \" + e_4);\n            return [2\n            /*return*/\n            , Promise.reject(e_4)];\n\n          case 6:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  HttpConnection.prototype.createConnectUrl = function (url, connectionToken) {\n    if (!connectionToken) {\n      return url;\n    }\n\n    return url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + (\"id=\" + connectionToken);\n  };\n\n  HttpConnection.prototype.createTransport = function (url, requestedTransport, negotiateResponse, requestedTransferFormat) {\n    return __awaiter(this, void 0, void 0, function () {\n      var connectUrl, transportExceptions, transports, negotiate, _i, transports_1, endpoint, transportOrError, ex_1, ex_2, message;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            connectUrl = this.createConnectUrl(url, negotiateResponse.connectionToken);\n            if (!this.isITransport(requestedTransport)) return [3\n            /*break*/\n            , 2];\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Debug, \"Connection was provided an instance of ITransport, using that directly.\");\n            this.transport = requestedTransport;\n            return [4\n            /*yield*/\n            , this.startTransport(connectUrl, requestedTransferFormat)];\n\n          case 1:\n            _a.sent();\n\n            this.connectionId = negotiateResponse.connectionId;\n            return [2\n            /*return*/\n            ];\n\n          case 2:\n            transportExceptions = [];\n            transports = negotiateResponse.availableTransports || [];\n            negotiate = negotiateResponse;\n            _i = 0, transports_1 = transports;\n            _a.label = 3;\n\n          case 3:\n            if (!(_i < transports_1.length)) return [3\n            /*break*/\n            , 13];\n            endpoint = transports_1[_i];\n            transportOrError = this.resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat);\n            if (!(transportOrError instanceof Error)) return [3\n            /*break*/\n            , 4]; // Store the error and continue, we don't want to cause a re-negotiate in these cases\n\n            transportExceptions.push(endpoint.transport + \" failed: \" + transportOrError);\n            return [3\n            /*break*/\n            , 12];\n\n          case 4:\n            if (!this.isITransport(transportOrError)) return [3\n            /*break*/\n            , 12];\n            this.transport = transportOrError;\n            if (!!negotiate) return [3\n            /*break*/\n            , 9];\n            _a.label = 5;\n\n          case 5:\n            _a.trys.push([5, 7,, 8]);\n\n            return [4\n            /*yield*/\n            , this.getNegotiationResponse(url)];\n\n          case 6:\n            negotiate = _a.sent();\n            return [3\n            /*break*/\n            , 8];\n\n          case 7:\n            ex_1 = _a.sent();\n            return [2\n            /*return*/\n            , Promise.reject(ex_1)];\n\n          case 8:\n            connectUrl = this.createConnectUrl(url, negotiate.connectionToken);\n            _a.label = 9;\n\n          case 9:\n            _a.trys.push([9, 11,, 12]);\n\n            return [4\n            /*yield*/\n            , this.startTransport(connectUrl, requestedTransferFormat)];\n\n          case 10:\n            _a.sent();\n\n            this.connectionId = negotiate.connectionId;\n            return [2\n            /*return*/\n            ];\n\n          case 11:\n            ex_2 = _a.sent();\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Error, \"Failed to start the transport '\" + endpoint.transport + \"': \" + ex_2);\n            negotiate = undefined;\n            transportExceptions.push(endpoint.transport + \" failed: \" + ex_2);\n\n            if (this.connectionState !== \"Connecting\"\n            /* Connecting */\n            ) {\n                message = \"Failed to select transport before stop() was called.\";\n                this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Debug, message);\n                return [2\n                /*return*/\n                , Promise.reject(new Error(message))];\n              }\n\n            return [3\n            /*break*/\n            , 12];\n\n          case 12:\n            _i++;\n            return [3\n            /*break*/\n            , 3];\n\n          case 13:\n            if (transportExceptions.length > 0) {\n              return [2\n              /*return*/\n              , Promise.reject(new Error(\"Unable to connect to the server with any of the available transports. \" + transportExceptions.join(\" \")))];\n            }\n\n            return [2\n            /*return*/\n            , Promise.reject(new Error(\"None of the transports supported by the client are supported by the server.\"))];\n        }\n      });\n    });\n  };\n\n  HttpConnection.prototype.constructTransport = function (transport) {\n    switch (transport) {\n      case _ITransport__WEBPACK_IMPORTED_MODULE_2__[\"HttpTransportType\"].WebSockets:\n        if (!this.options.WebSocket) {\n          throw new Error(\"'WebSocket' is not supported in your environment.\");\n        }\n\n        return new _WebSocketTransport__WEBPACK_IMPORTED_MODULE_6__[\"WebSocketTransport\"](this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.WebSocket, this.options.headers || {});\n\n      case _ITransport__WEBPACK_IMPORTED_MODULE_2__[\"HttpTransportType\"].ServerSentEvents:\n        if (!this.options.EventSource) {\n          throw new Error(\"'EventSource' is not supported in your environment.\");\n        }\n\n        return new _ServerSentEventsTransport__WEBPACK_IMPORTED_MODULE_4__[\"ServerSentEventsTransport\"](this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.EventSource, this.options.withCredentials, this.options.headers || {});\n\n      case _ITransport__WEBPACK_IMPORTED_MODULE_2__[\"HttpTransportType\"].LongPolling:\n        return new _LongPollingTransport__WEBPACK_IMPORTED_MODULE_3__[\"LongPollingTransport\"](this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.withCredentials, this.options.headers || {});\n\n      default:\n        throw new Error(\"Unknown transport: \" + transport + \".\");\n    }\n  };\n\n  HttpConnection.prototype.startTransport = function (url, transferFormat) {\n    var _this = this;\n\n    this.transport.onreceive = this.onreceive;\n\n    this.transport.onclose = function (e) {\n      return _this.stopConnection(e);\n    };\n\n    return this.transport.connect(url, transferFormat);\n  };\n\n  HttpConnection.prototype.resolveTransportOrError = function (endpoint, requestedTransport, requestedTransferFormat) {\n    var transport = _ITransport__WEBPACK_IMPORTED_MODULE_2__[\"HttpTransportType\"][endpoint.transport];\n\n    if (transport === null || transport === undefined) {\n      this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Debug, \"Skipping transport '\" + endpoint.transport + \"' because it is not supported by this client.\");\n      return new Error(\"Skipping transport '\" + endpoint.transport + \"' because it is not supported by this client.\");\n    } else {\n      if (transportMatches(requestedTransport, transport)) {\n        var transferFormats = endpoint.transferFormats.map(function (s) {\n          return _ITransport__WEBPACK_IMPORTED_MODULE_2__[\"TransferFormat\"][s];\n        });\n\n        if (transferFormats.indexOf(requestedTransferFormat) >= 0) {\n          if (transport === _ITransport__WEBPACK_IMPORTED_MODULE_2__[\"HttpTransportType\"].WebSockets && !this.options.WebSocket || transport === _ITransport__WEBPACK_IMPORTED_MODULE_2__[\"HttpTransportType\"].ServerSentEvents && !this.options.EventSource) {\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Debug, \"Skipping transport '\" + _ITransport__WEBPACK_IMPORTED_MODULE_2__[\"HttpTransportType\"][transport] + \"' because it is not supported in your environment.'\");\n            return new Error(\"'\" + _ITransport__WEBPACK_IMPORTED_MODULE_2__[\"HttpTransportType\"][transport] + \"' is not supported in your environment.\");\n          } else {\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Debug, \"Selecting transport '\" + _ITransport__WEBPACK_IMPORTED_MODULE_2__[\"HttpTransportType\"][transport] + \"'.\");\n\n            try {\n              return this.constructTransport(transport);\n            } catch (ex) {\n              return ex;\n            }\n          }\n        } else {\n          this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Debug, \"Skipping transport '\" + _ITransport__WEBPACK_IMPORTED_MODULE_2__[\"HttpTransportType\"][transport] + \"' because it does not support the requested transfer format '\" + _ITransport__WEBPACK_IMPORTED_MODULE_2__[\"TransferFormat\"][requestedTransferFormat] + \"'.\");\n          return new Error(\"'\" + _ITransport__WEBPACK_IMPORTED_MODULE_2__[\"HttpTransportType\"][transport] + \"' does not support \" + _ITransport__WEBPACK_IMPORTED_MODULE_2__[\"TransferFormat\"][requestedTransferFormat] + \".\");\n        }\n      } else {\n        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Debug, \"Skipping transport '\" + _ITransport__WEBPACK_IMPORTED_MODULE_2__[\"HttpTransportType\"][transport] + \"' because it was disabled by the client.\");\n        return new Error(\"'\" + _ITransport__WEBPACK_IMPORTED_MODULE_2__[\"HttpTransportType\"][transport] + \"' is disabled by the client.\");\n      }\n    }\n  };\n\n  HttpConnection.prototype.isITransport = function (transport) {\n    return transport && typeof transport === \"object\" && \"connect\" in transport;\n  };\n\n  HttpConnection.prototype.stopConnection = function (error) {\n    var _this = this;\n\n    this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Debug, \"HttpConnection.stopConnection(\" + error + \") called while in state \" + this.connectionState + \".\");\n    this.transport = undefined; // If we have a stopError, it takes precedence over the error from the transport\n\n    error = this.stopError || error;\n    this.stopError = undefined;\n\n    if (this.connectionState === \"Disconnected\"\n    /* Disconnected */\n    ) {\n        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Debug, \"Call to HttpConnection.stopConnection(\" + error + \") was ignored because the connection is already in the disconnected state.\");\n        return;\n      }\n\n    if (this.connectionState === \"Connecting\"\n    /* Connecting */\n    ) {\n        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Warning, \"Call to HttpConnection.stopConnection(\" + error + \") was ignored because the connection is still in the connecting state.\");\n        throw new Error(\"HttpConnection.stopConnection(\" + error + \") was called while the connection is still in the connecting state.\");\n      }\n\n    if (this.connectionState === \"Disconnecting\"\n    /* Disconnecting */\n    ) {\n        // A call to stop() induced this call to stopConnection and needs to be completed.\n        // Any stop() awaiters will be scheduled to continue after the onclose callback fires.\n        this.stopPromiseResolver();\n      }\n\n    if (error) {\n      this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Error, \"Connection disconnected with error '\" + error + \"'.\");\n    } else {\n      this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Information, \"Connection disconnected.\");\n    }\n\n    if (this.sendQueue) {\n      this.sendQueue.stop().catch(function (e) {\n        _this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Error, \"TransportSendQueue.stop() threw error '\" + e + \"'.\");\n      });\n      this.sendQueue = undefined;\n    }\n\n    this.connectionId = undefined;\n    this.connectionState = \"Disconnected\"\n    /* Disconnected */\n    ;\n\n    if (this.connectionStarted) {\n      this.connectionStarted = false;\n\n      try {\n        if (this.onclose) {\n          this.onclose(error);\n        }\n      } catch (e) {\n        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Error, \"HttpConnection.onclose(\" + error + \") threw error '\" + e + \"'.\");\n      }\n    }\n  };\n\n  HttpConnection.prototype.resolveUrl = function (url) {\n    // startsWith is not supported in IE\n    if (url.lastIndexOf(\"https://\", 0) === 0 || url.lastIndexOf(\"http://\", 0) === 0) {\n      return url;\n    }\n\n    if (!_Utils__WEBPACK_IMPORTED_MODULE_5__[\"Platform\"].isBrowser || !window.document) {\n      throw new Error(\"Cannot resolve '\" + url + \"'.\");\n    } // Setting the url to the href propery of an anchor tag handles normalization\n    // for us. There are 3 main cases.\n    // 1. Relative path normalization e.g \"b\" -> \"http://localhost:5000/a/b\"\n    // 2. Absolute path normalization e.g \"/a/b\" -> \"http://localhost:5000/a/b\"\n    // 3. Networkpath reference normalization e.g \"//localhost:5000/a/b\" -> \"http://localhost:5000/a/b\"\n\n\n    var aTag = window.document.createElement(\"a\");\n    aTag.href = url;\n    this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Information, \"Normalizing '\" + url + \"' to '\" + aTag.href + \"'.\");\n    return aTag.href;\n  };\n\n  HttpConnection.prototype.resolveNegotiateUrl = function (url) {\n    var index = url.indexOf(\"?\");\n    var negotiateUrl = url.substring(0, index === -1 ? url.length : index);\n\n    if (negotiateUrl[negotiateUrl.length - 1] !== \"/\") {\n      negotiateUrl += \"/\";\n    }\n\n    negotiateUrl += \"negotiate\";\n    negotiateUrl += index === -1 ? \"\" : url.substring(index);\n\n    if (negotiateUrl.indexOf(\"negotiateVersion\") === -1) {\n      negotiateUrl += index === -1 ? \"?\" : \"&\";\n      negotiateUrl += \"negotiateVersion=\" + this.negotiateVersion;\n    }\n\n    return negotiateUrl;\n  };\n\n  return HttpConnection;\n}();\n\n\n\nfunction transportMatches(requestedTransport, actualTransport) {\n  return !requestedTransport || (actualTransport & requestedTransport) !== 0;\n}\n/** @private */\n\n\nvar TransportSendQueue =\n/** @class */\nfunction () {\n  function TransportSendQueue(transport) {\n    this.transport = transport;\n    this.buffer = [];\n    this.executing = true;\n    this.sendBufferedData = new PromiseSource();\n    this.transportResult = new PromiseSource();\n    this.sendLoopPromise = this.sendLoop();\n  }\n\n  TransportSendQueue.prototype.send = function (data) {\n    this.bufferData(data);\n\n    if (!this.transportResult) {\n      this.transportResult = new PromiseSource();\n    }\n\n    return this.transportResult.promise;\n  };\n\n  TransportSendQueue.prototype.stop = function () {\n    this.executing = false;\n    this.sendBufferedData.resolve();\n    return this.sendLoopPromise;\n  };\n\n  TransportSendQueue.prototype.bufferData = function (data) {\n    if (this.buffer.length && typeof this.buffer[0] !== typeof data) {\n      throw new Error(\"Expected data to be of type \" + typeof this.buffer + \" but was of type \" + typeof data);\n    }\n\n    this.buffer.push(data);\n    this.sendBufferedData.resolve();\n  };\n\n  TransportSendQueue.prototype.sendLoop = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var transportResult, data, error_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (false) {}\n            return [4\n            /*yield*/\n            , this.sendBufferedData.promise];\n\n          case 1:\n            _a.sent();\n\n            if (!this.executing) {\n              if (this.transportResult) {\n                this.transportResult.reject(\"Connection stopped.\");\n              }\n\n              return [3\n              /*break*/\n              , 6];\n            }\n\n            this.sendBufferedData = new PromiseSource();\n            transportResult = this.transportResult;\n            this.transportResult = undefined;\n            data = typeof this.buffer[0] === \"string\" ? this.buffer.join(\"\") : TransportSendQueue.concatBuffers(this.buffer);\n            this.buffer.length = 0;\n            _a.label = 2;\n\n          case 2:\n            _a.trys.push([2, 4,, 5]);\n\n            return [4\n            /*yield*/\n            , this.transport.send(data)];\n\n          case 3:\n            _a.sent();\n\n            transportResult.resolve();\n            return [3\n            /*break*/\n            , 5];\n\n          case 4:\n            error_1 = _a.sent();\n            transportResult.reject(error_1);\n            return [3\n            /*break*/\n            , 5];\n\n          case 5:\n            return [3\n            /*break*/\n            , 0];\n\n          case 6:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  TransportSendQueue.concatBuffers = function (arrayBuffers) {\n    var totalLength = arrayBuffers.map(function (b) {\n      return b.byteLength;\n    }).reduce(function (a, b) {\n      return a + b;\n    });\n    var result = new Uint8Array(totalLength);\n    var offset = 0;\n\n    for (var _i = 0, arrayBuffers_1 = arrayBuffers; _i < arrayBuffers_1.length; _i++) {\n      var item = arrayBuffers_1[_i];\n      result.set(new Uint8Array(item), offset);\n      offset += item.byteLength;\n    }\n\n    return result.buffer;\n  };\n\n  return TransportSendQueue;\n}();\n\n\n\nvar PromiseSource =\n/** @class */\nfunction () {\n  function PromiseSource() {\n    var _this = this;\n\n    this.promise = new Promise(function (resolve, reject) {\n      var _a;\n\n      return _a = [resolve, reject], _this.resolver = _a[0], _this.rejecter = _a[1], _a;\n    });\n  }\n\n  PromiseSource.prototype.resolve = function () {\n    this.resolver();\n  };\n\n  PromiseSource.prototype.reject = function (reason) {\n    this.rejecter(reason);\n  };\n\n  return PromiseSource;\n}();\n\n//# sourceURL=webpack:///./node_modules/@microsoft/signalr/dist/esm/HttpConnection.js?");

/***/ }),

/***/ "2zAs":
/*!*********************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/JsonHubProtocol.js ***!
  \*********************************************************************/
/*! exports provided: JsonHubProtocol */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"JsonHubProtocol\", function() { return JsonHubProtocol; });\n/* harmony import */ var _IHubProtocol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./IHubProtocol */ \"++1n\");\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ILogger */ \"M+GD\");\n/* harmony import */ var _ITransport__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ITransport */ \"qFkC\");\n/* harmony import */ var _Loggers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Loggers */ \"v3Fn\");\n/* harmony import */ var _TextMessageFormat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TextMessageFormat */ \"PMyv\");\n// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\n\n\n\n\n\nvar JSON_HUB_PROTOCOL_NAME = \"json\";\n/** Implements the JSON Hub Protocol. */\n\nvar JsonHubProtocol =\n/** @class */\nfunction () {\n  function JsonHubProtocol() {\n    /** @inheritDoc */\n    this.name = JSON_HUB_PROTOCOL_NAME;\n    /** @inheritDoc */\n\n    this.version = 1;\n    /** @inheritDoc */\n\n    this.transferFormat = _ITransport__WEBPACK_IMPORTED_MODULE_2__[\"TransferFormat\"].Text;\n  }\n  /** Creates an array of {@link @microsoft/signalr.HubMessage} objects from the specified serialized representation.\r\n   *\r\n   * @param {string} input A string containing the serialized representation.\r\n   * @param {ILogger} logger A logger that will be used to log messages that occur during parsing.\r\n   */\n\n\n  JsonHubProtocol.prototype.parseMessages = function (input, logger) {\n    // The interface does allow \"ArrayBuffer\" to be passed in, but this implementation does not. So let's throw a useful error.\n    if (typeof input !== \"string\") {\n      throw new Error(\"Invalid input for JSON hub protocol. Expected a string.\");\n    }\n\n    if (!input) {\n      return [];\n    }\n\n    if (logger === null) {\n      logger = _Loggers__WEBPACK_IMPORTED_MODULE_3__[\"NullLogger\"].instance;\n    } // Parse the messages\n\n\n    var messages = _TextMessageFormat__WEBPACK_IMPORTED_MODULE_4__[\"TextMessageFormat\"].parse(input);\n    var hubMessages = [];\n\n    for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {\n      var message = messages_1[_i];\n      var parsedMessage = JSON.parse(message);\n\n      if (typeof parsedMessage.type !== \"number\") {\n        throw new Error(\"Invalid payload.\");\n      }\n\n      switch (parsedMessage.type) {\n        case _IHubProtocol__WEBPACK_IMPORTED_MODULE_0__[\"MessageType\"].Invocation:\n          this.isInvocationMessage(parsedMessage);\n          break;\n\n        case _IHubProtocol__WEBPACK_IMPORTED_MODULE_0__[\"MessageType\"].StreamItem:\n          this.isStreamItemMessage(parsedMessage);\n          break;\n\n        case _IHubProtocol__WEBPACK_IMPORTED_MODULE_0__[\"MessageType\"].Completion:\n          this.isCompletionMessage(parsedMessage);\n          break;\n\n        case _IHubProtocol__WEBPACK_IMPORTED_MODULE_0__[\"MessageType\"].Ping:\n          // Single value, no need to validate\n          break;\n\n        case _IHubProtocol__WEBPACK_IMPORTED_MODULE_0__[\"MessageType\"].Close:\n          // All optional values, no need to validate\n          break;\n\n        default:\n          // Future protocol changes can add message types, old clients can ignore them\n          logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Information, \"Unknown message type '\" + parsedMessage.type + \"' ignored.\");\n          continue;\n      }\n\n      hubMessages.push(parsedMessage);\n    }\n\n    return hubMessages;\n  };\n  /** Writes the specified {@link @microsoft/signalr.HubMessage} to a string and returns it.\r\n   *\r\n   * @param {HubMessage} message The message to write.\r\n   * @returns {string} A string containing the serialized representation of the message.\r\n   */\n\n\n  JsonHubProtocol.prototype.writeMessage = function (message) {\n    return _TextMessageFormat__WEBPACK_IMPORTED_MODULE_4__[\"TextMessageFormat\"].write(JSON.stringify(message));\n  };\n\n  JsonHubProtocol.prototype.isInvocationMessage = function (message) {\n    this.assertNotEmptyString(message.target, \"Invalid payload for Invocation message.\");\n\n    if (message.invocationId !== undefined) {\n      this.assertNotEmptyString(message.invocationId, \"Invalid payload for Invocation message.\");\n    }\n  };\n\n  JsonHubProtocol.prototype.isStreamItemMessage = function (message) {\n    this.assertNotEmptyString(message.invocationId, \"Invalid payload for StreamItem message.\");\n\n    if (message.item === undefined) {\n      throw new Error(\"Invalid payload for StreamItem message.\");\n    }\n  };\n\n  JsonHubProtocol.prototype.isCompletionMessage = function (message) {\n    if (message.result && message.error) {\n      throw new Error(\"Invalid payload for Completion message.\");\n    }\n\n    if (!message.result && message.error) {\n      this.assertNotEmptyString(message.error, \"Invalid payload for Completion message.\");\n    }\n\n    this.assertNotEmptyString(message.invocationId, \"Invalid payload for Completion message.\");\n  };\n\n  JsonHubProtocol.prototype.assertNotEmptyString = function (value, errorMessage) {\n    if (typeof value !== \"string\" || value === \"\") {\n      throw new Error(errorMessage);\n    }\n  };\n\n  return JsonHubProtocol;\n}();\n\n\n\n//# sourceURL=webpack:///./node_modules/@microsoft/signalr/dist/esm/JsonHubProtocol.js?");

/***/ }),

/***/ "5/gN":
/*!*********************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/AbortController.js ***!
  \*********************************************************************/
/*! exports provided: AbortController */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AbortController\", function() { return AbortController; });\n// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\n// Rough polyfill of https://developer.mozilla.org/en-US/docs/Web/API/AbortController\n// We don't actually ever use the API being polyfilled, we always use the polyfill because\n// it's a very new API right now.\n// Not exported from index.\n\n/** @private */\nvar AbortController =\n/** @class */\nfunction () {\n  function AbortController() {\n    this.isAborted = false;\n    this.onabort = null;\n  }\n\n  AbortController.prototype.abort = function () {\n    if (!this.isAborted) {\n      this.isAborted = true;\n\n      if (this.onabort) {\n        this.onabort();\n      }\n    }\n  };\n\n  Object.defineProperty(AbortController.prototype, \"signal\", {\n    get: function () {\n      return this;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AbortController.prototype, \"aborted\", {\n    get: function () {\n      return this.isAborted;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return AbortController;\n}();\n\n\n\n//# sourceURL=webpack:///./node_modules/@microsoft/signalr/dist/esm/AbortController.js?");

/***/ }),

/***/ "6HpG":
/*!***********************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/index.js ***!
  \***********************************************************/
/*! exports provided: AbortError, HttpError, TimeoutError, HttpClient, HttpResponse, DefaultHttpClient, HubConnection, HubConnectionState, HubConnectionBuilder, MessageType, LogLevel, HttpTransportType, TransferFormat, NullLogger, JsonHubProtocol, Subject, VERSION */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Errors */ \"9BRb\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"AbortError\", function() { return _Errors__WEBPACK_IMPORTED_MODULE_0__[\"AbortError\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"HttpError\", function() { return _Errors__WEBPACK_IMPORTED_MODULE_0__[\"HttpError\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TimeoutError\", function() { return _Errors__WEBPACK_IMPORTED_MODULE_0__[\"TimeoutError\"]; });\n\n/* harmony import */ var _HttpClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HttpClient */ \"Rlqr\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"HttpClient\", function() { return _HttpClient__WEBPACK_IMPORTED_MODULE_1__[\"HttpClient\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"HttpResponse\", function() { return _HttpClient__WEBPACK_IMPORTED_MODULE_1__[\"HttpResponse\"]; });\n\n/* harmony import */ var _DefaultHttpClient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DefaultHttpClient */ \"Ysxs\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DefaultHttpClient\", function() { return _DefaultHttpClient__WEBPACK_IMPORTED_MODULE_2__[\"DefaultHttpClient\"]; });\n\n/* harmony import */ var _HubConnection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./HubConnection */ \"mLhb\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"HubConnection\", function() { return _HubConnection__WEBPACK_IMPORTED_MODULE_3__[\"HubConnection\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"HubConnectionState\", function() { return _HubConnection__WEBPACK_IMPORTED_MODULE_3__[\"HubConnectionState\"]; });\n\n/* harmony import */ var _HubConnectionBuilder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./HubConnectionBuilder */ \"utQ/\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"HubConnectionBuilder\", function() { return _HubConnectionBuilder__WEBPACK_IMPORTED_MODULE_4__[\"HubConnectionBuilder\"]; });\n\n/* harmony import */ var _IHubProtocol__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./IHubProtocol */ \"++1n\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MessageType\", function() { return _IHubProtocol__WEBPACK_IMPORTED_MODULE_5__[\"MessageType\"]; });\n\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ILogger */ \"M+GD\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"LogLevel\", function() { return _ILogger__WEBPACK_IMPORTED_MODULE_6__[\"LogLevel\"]; });\n\n/* harmony import */ var _ITransport__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ITransport */ \"qFkC\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"HttpTransportType\", function() { return _ITransport__WEBPACK_IMPORTED_MODULE_7__[\"HttpTransportType\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TransferFormat\", function() { return _ITransport__WEBPACK_IMPORTED_MODULE_7__[\"TransferFormat\"]; });\n\n/* harmony import */ var _Loggers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Loggers */ \"v3Fn\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NullLogger\", function() { return _Loggers__WEBPACK_IMPORTED_MODULE_8__[\"NullLogger\"]; });\n\n/* harmony import */ var _JsonHubProtocol__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./JsonHubProtocol */ \"2zAs\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"JsonHubProtocol\", function() { return _JsonHubProtocol__WEBPACK_IMPORTED_MODULE_9__[\"JsonHubProtocol\"]; });\n\n/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Subject */ \"z2YZ\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Subject\", function() { return _Subject__WEBPACK_IMPORTED_MODULE_10__[\"Subject\"]; });\n\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Utils */ \"ftFU\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"VERSION\", function() { return _Utils__WEBPACK_IMPORTED_MODULE_11__[\"VERSION\"]; });\n\n// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack:///./node_modules/@microsoft/signalr/dist/esm/index.js?");

/***/ }),

/***/ "6xqK":
/*!************************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/WebSocketTransport.js ***!
  \************************************************************************/
/*! exports provided: WebSocketTransport */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WebSocketTransport\", function() { return WebSocketTransport; });\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ILogger */ \"M+GD\");\n/* harmony import */ var _ITransport__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ITransport */ \"qFkC\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utils */ \"ftFU\");\n// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\nvar __assign = undefined && undefined.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n  }\n\n  return t;\n};\n\nvar __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = undefined && undefined.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\n\n\n\n/** @private */\n\nvar WebSocketTransport =\n/** @class */\nfunction () {\n  function WebSocketTransport(httpClient, accessTokenFactory, logger, logMessageContent, webSocketConstructor, headers) {\n    this.logger = logger;\n    this.accessTokenFactory = accessTokenFactory;\n    this.logMessageContent = logMessageContent;\n    this.webSocketConstructor = webSocketConstructor;\n    this.httpClient = httpClient;\n    this.onreceive = null;\n    this.onclose = null;\n    this.headers = headers;\n  }\n\n  WebSocketTransport.prototype.connect = function (url, transferFormat) {\n    return __awaiter(this, void 0, void 0, function () {\n      var token;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _Utils__WEBPACK_IMPORTED_MODULE_2__[\"Arg\"].isRequired(url, \"url\");\n            _Utils__WEBPACK_IMPORTED_MODULE_2__[\"Arg\"].isRequired(transferFormat, \"transferFormat\");\n            _Utils__WEBPACK_IMPORTED_MODULE_2__[\"Arg\"].isIn(transferFormat, _ITransport__WEBPACK_IMPORTED_MODULE_1__[\"TransferFormat\"], \"transferFormat\");\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__[\"LogLevel\"].Trace, \"(WebSockets transport) Connecting.\");\n            if (!this.accessTokenFactory) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.accessTokenFactory()];\n\n          case 1:\n            token = _a.sent();\n\n            if (token) {\n              url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + (\"access_token=\" + encodeURIComponent(token));\n            }\n\n            _a.label = 2;\n\n          case 2:\n            return [2\n            /*return*/\n            , new Promise(function (resolve, reject) {\n              url = url.replace(/^http/, \"ws\");\n              var webSocket;\n\n              var cookies = _this.httpClient.getCookieString(url);\n\n              var opened = false;\n\n              if (_Utils__WEBPACK_IMPORTED_MODULE_2__[\"Platform\"].isNode) {\n                var headers = {};\n\n                var _a = Object(_Utils__WEBPACK_IMPORTED_MODULE_2__[\"getUserAgentHeader\"])(),\n                    name_1 = _a[0],\n                    value = _a[1];\n\n                headers[name_1] = value;\n\n                if (cookies) {\n                  headers[\"Cookie\"] = \"\" + cookies;\n                } // Only pass headers when in non-browser environments\n\n\n                webSocket = new _this.webSocketConstructor(url, undefined, {\n                  headers: __assign({}, headers, _this.headers)\n                });\n              }\n\n              if (!webSocket) {\n                // Chrome is not happy with passing 'undefined' as protocol\n                webSocket = new _this.webSocketConstructor(url);\n              }\n\n              if (transferFormat === _ITransport__WEBPACK_IMPORTED_MODULE_1__[\"TransferFormat\"].Binary) {\n                webSocket.binaryType = \"arraybuffer\";\n              } // tslint:disable-next-line:variable-name\n\n\n              webSocket.onopen = function (_event) {\n                _this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__[\"LogLevel\"].Information, \"WebSocket connected to \" + url + \".\");\n\n                _this.webSocket = webSocket;\n                opened = true;\n                resolve();\n              };\n\n              webSocket.onerror = function (event) {\n                var error = null; // ErrorEvent is a browser only type we need to check if the type exists before using it\n\n                if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\n                  error = event.error;\n                } else {\n                  error = new Error(\"There was an error with the transport.\");\n                }\n\n                reject(error);\n              };\n\n              webSocket.onmessage = function (message) {\n                _this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__[\"LogLevel\"].Trace, \"(WebSockets transport) data received. \" + Object(_Utils__WEBPACK_IMPORTED_MODULE_2__[\"getDataDetail\"])(message.data, _this.logMessageContent) + \".\");\n\n                if (_this.onreceive) {\n                  try {\n                    _this.onreceive(message.data);\n                  } catch (error) {\n                    _this.close(error);\n\n                    return;\n                  }\n                }\n              };\n\n              webSocket.onclose = function (event) {\n                // Don't call close handler if connection was never established\n                // We'll reject the connect call instead\n                if (opened) {\n                  _this.close(event);\n                } else {\n                  var error = null; // ErrorEvent is a browser only type we need to check if the type exists before using it\n\n                  if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\n                    error = event.error;\n                  } else {\n                    error = new Error(\"There was an error with the transport.\");\n                  }\n\n                  reject(error);\n                }\n              };\n            })];\n        }\n      });\n    });\n  };\n\n  WebSocketTransport.prototype.send = function (data) {\n    if (this.webSocket && this.webSocket.readyState === this.webSocketConstructor.OPEN) {\n      this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__[\"LogLevel\"].Trace, \"(WebSockets transport) sending data. \" + Object(_Utils__WEBPACK_IMPORTED_MODULE_2__[\"getDataDetail\"])(data, this.logMessageContent) + \".\");\n      this.webSocket.send(data);\n      return Promise.resolve();\n    }\n\n    return Promise.reject(\"WebSocket is not in the OPEN state\");\n  };\n\n  WebSocketTransport.prototype.stop = function () {\n    if (this.webSocket) {\n      // Manually invoke onclose callback inline so we know the HttpConnection was closed properly before returning\n      // This also solves an issue where websocket.onclose could take 18+ seconds to trigger during network disconnects\n      this.close(undefined);\n    }\n\n    return Promise.resolve();\n  };\n\n  WebSocketTransport.prototype.close = function (event) {\n    // webSocket will be null if the transport did not start successfully\n    if (this.webSocket) {\n      // Clear websocket handlers because we are considering the socket closed now\n      this.webSocket.onclose = function () {};\n\n      this.webSocket.onmessage = function () {};\n\n      this.webSocket.onerror = function () {};\n\n      this.webSocket.close();\n      this.webSocket = undefined;\n    }\n\n    this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__[\"LogLevel\"].Trace, \"(WebSockets transport) socket closed.\");\n\n    if (this.onclose) {\n      if (this.isCloseEvent(event) && (event.wasClean === false || event.code !== 1000)) {\n        this.onclose(new Error(\"WebSocket closed with status code: \" + event.code + \" (\" + event.reason + \").\"));\n      } else if (event instanceof Error) {\n        this.onclose(event);\n      } else {\n        this.onclose();\n      }\n    }\n  };\n\n  WebSocketTransport.prototype.isCloseEvent = function (event) {\n    return event && typeof event.wasClean === \"boolean\" && typeof event.code === \"number\";\n  };\n\n  return WebSocketTransport;\n}();\n\n\n\n//# sourceURL=webpack:///./node_modules/@microsoft/signalr/dist/esm/WebSocketTransport.js?");

/***/ }),

/***/ "9BRb":
/*!************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/Errors.js ***!
  \************************************************************/
/*! exports provided: HttpError, TimeoutError, AbortError */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HttpError\", function() { return HttpError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TimeoutError\", function() { return TimeoutError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AbortError\", function() { return AbortError; });\n// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\nvar __extends = undefined && undefined.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/** Error thrown when an HTTP request fails. */\n\n\nvar HttpError =\n/** @class */\nfunction (_super) {\n  __extends(HttpError, _super);\n  /** Constructs a new instance of {@link @microsoft/signalr.HttpError}.\r\n   *\r\n   * @param {string} errorMessage A descriptive error message.\r\n   * @param {number} statusCode The HTTP status code represented by this error.\r\n   */\n\n\n  function HttpError(errorMessage, statusCode) {\n    var _newTarget = this.constructor;\n\n    var _this = this;\n\n    var trueProto = _newTarget.prototype;\n    _this = _super.call(this, errorMessage) || this;\n    _this.statusCode = statusCode; // Workaround issue in Typescript compiler\n    // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\n\n    _this.__proto__ = trueProto;\n    return _this;\n  }\n\n  return HttpError;\n}(Error);\n\n\n/** Error thrown when a timeout elapses. */\n\nvar TimeoutError =\n/** @class */\nfunction (_super) {\n  __extends(TimeoutError, _super);\n  /** Constructs a new instance of {@link @microsoft/signalr.TimeoutError}.\r\n   *\r\n   * @param {string} errorMessage A descriptive error message.\r\n   */\n\n\n  function TimeoutError(errorMessage) {\n    var _newTarget = this.constructor;\n\n    if (errorMessage === void 0) {\n      errorMessage = \"A timeout occurred.\";\n    }\n\n    var _this = this;\n\n    var trueProto = _newTarget.prototype;\n    _this = _super.call(this, errorMessage) || this; // Workaround issue in Typescript compiler\n    // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\n\n    _this.__proto__ = trueProto;\n    return _this;\n  }\n\n  return TimeoutError;\n}(Error);\n\n\n/** Error thrown when an action is aborted. */\n\nvar AbortError =\n/** @class */\nfunction (_super) {\n  __extends(AbortError, _super);\n  /** Constructs a new instance of {@link AbortError}.\r\n   *\r\n   * @param {string} errorMessage A descriptive error message.\r\n   */\n\n\n  function AbortError(errorMessage) {\n    var _newTarget = this.constructor;\n\n    if (errorMessage === void 0) {\n      errorMessage = \"An abort occurred.\";\n    }\n\n    var _this = this;\n\n    var trueProto = _newTarget.prototype;\n    _this = _super.call(this, errorMessage) || this; // Workaround issue in Typescript compiler\n    // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\n\n    _this.__proto__ = trueProto;\n    return _this;\n  }\n\n  return AbortError;\n}(Error);\n\n\n\n//# sourceURL=webpack:///./node_modules/@microsoft/signalr/dist/esm/Errors.js?");

/***/ }),

/***/ "C/dI":
/*!**************************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/LongPollingTransport.js ***!
  \**************************************************************************/
/*! exports provided: LongPollingTransport */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LongPollingTransport\", function() { return LongPollingTransport; });\n/* harmony import */ var _AbortController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AbortController */ \"5/gN\");\n/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Errors */ \"9BRb\");\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ILogger */ \"M+GD\");\n/* harmony import */ var _ITransport__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ITransport */ \"qFkC\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Utils */ \"ftFU\");\n// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\nvar __assign = undefined && undefined.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n  }\n\n  return t;\n};\n\nvar __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = undefined && undefined.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\n\n\n\n\n // Not exported from 'index', this type is internal.\n\n/** @private */\n\nvar LongPollingTransport =\n/** @class */\nfunction () {\n  function LongPollingTransport(httpClient, accessTokenFactory, logger, logMessageContent, withCredentials, headers) {\n    this.httpClient = httpClient;\n    this.accessTokenFactory = accessTokenFactory;\n    this.logger = logger;\n    this.pollAbort = new _AbortController__WEBPACK_IMPORTED_MODULE_0__[\"AbortController\"]();\n    this.logMessageContent = logMessageContent;\n    this.withCredentials = withCredentials;\n    this.headers = headers;\n    this.running = false;\n    this.onreceive = null;\n    this.onclose = null;\n  }\n\n  Object.defineProperty(LongPollingTransport.prototype, \"pollAborted\", {\n    // This is an internal type, not exported from 'index' so this is really just internal.\n    get: function () {\n      return this.pollAbort.aborted;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  LongPollingTransport.prototype.connect = function (url, transferFormat) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, _b, name, value, headers, pollOptions, token, pollUrl, response;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            _Utils__WEBPACK_IMPORTED_MODULE_4__[\"Arg\"].isRequired(url, \"url\");\n            _Utils__WEBPACK_IMPORTED_MODULE_4__[\"Arg\"].isRequired(transferFormat, \"transferFormat\");\n            _Utils__WEBPACK_IMPORTED_MODULE_4__[\"Arg\"].isIn(transferFormat, _ITransport__WEBPACK_IMPORTED_MODULE_3__[\"TransferFormat\"], \"transferFormat\");\n            this.url = url;\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Trace, \"(LongPolling transport) Connecting.\"); // Allow binary format on Node and Browsers that support binary content (indicated by the presence of responseType property)\n\n            if (transferFormat === _ITransport__WEBPACK_IMPORTED_MODULE_3__[\"TransferFormat\"].Binary && typeof XMLHttpRequest !== \"undefined\" && typeof new XMLHttpRequest().responseType !== \"string\") {\n              throw new Error(\"Binary protocols over XmlHttpRequest not implementing advanced features are not supported.\");\n            }\n\n            _b = Object(_Utils__WEBPACK_IMPORTED_MODULE_4__[\"getUserAgentHeader\"])(), name = _b[0], value = _b[1];\n            headers = __assign((_a = {}, _a[name] = value, _a), this.headers);\n            pollOptions = {\n              abortSignal: this.pollAbort.signal,\n              headers: headers,\n              timeout: 100000,\n              withCredentials: this.withCredentials\n            };\n\n            if (transferFormat === _ITransport__WEBPACK_IMPORTED_MODULE_3__[\"TransferFormat\"].Binary) {\n              pollOptions.responseType = \"arraybuffer\";\n            }\n\n            return [4\n            /*yield*/\n            , this.getAccessToken()];\n\n          case 1:\n            token = _c.sent();\n            this.updateHeaderToken(pollOptions, token);\n            pollUrl = url + \"&_=\" + Date.now();\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Trace, \"(LongPolling transport) polling: \" + pollUrl + \".\");\n            return [4\n            /*yield*/\n            , this.httpClient.get(pollUrl, pollOptions)];\n\n          case 2:\n            response = _c.sent();\n\n            if (response.statusCode !== 200) {\n              this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Error, \"(LongPolling transport) Unexpected response code: \" + response.statusCode + \".\"); // Mark running as false so that the poll immediately ends and runs the close logic\n\n              this.closeError = new _Errors__WEBPACK_IMPORTED_MODULE_1__[\"HttpError\"](response.statusText || \"\", response.statusCode);\n              this.running = false;\n            } else {\n              this.running = true;\n            }\n\n            this.receiving = this.poll(this.url, pollOptions);\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  LongPollingTransport.prototype.getAccessToken = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.accessTokenFactory) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.accessTokenFactory()];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.sent()];\n\n          case 2:\n            return [2\n            /*return*/\n            , null];\n        }\n      });\n    });\n  };\n\n  LongPollingTransport.prototype.updateHeaderToken = function (request, token) {\n    if (!request.headers) {\n      request.headers = {};\n    }\n\n    if (token) {\n      // tslint:disable-next-line:no-string-literal\n      request.headers[\"Authorization\"] = \"Bearer \" + token;\n      return;\n    } // tslint:disable-next-line:no-string-literal\n\n\n    if (request.headers[\"Authorization\"]) {\n      // tslint:disable-next-line:no-string-literal\n      delete request.headers[\"Authorization\"];\n    }\n  };\n\n  LongPollingTransport.prototype.poll = function (url, pollOptions) {\n    return __awaiter(this, void 0, void 0, function () {\n      var token, pollUrl, response, e_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0,, 8, 9]);\n\n            _a.label = 1;\n\n          case 1:\n            if (!this.running) return [3\n            /*break*/\n            , 7];\n            return [4\n            /*yield*/\n            , this.getAccessToken()];\n\n          case 2:\n            token = _a.sent();\n            this.updateHeaderToken(pollOptions, token);\n            _a.label = 3;\n\n          case 3:\n            _a.trys.push([3, 5,, 6]);\n\n            pollUrl = url + \"&_=\" + Date.now();\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Trace, \"(LongPolling transport) polling: \" + pollUrl + \".\");\n            return [4\n            /*yield*/\n            , this.httpClient.get(pollUrl, pollOptions)];\n\n          case 4:\n            response = _a.sent();\n\n            if (response.statusCode === 204) {\n              this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Information, \"(LongPolling transport) Poll terminated by server.\");\n              this.running = false;\n            } else if (response.statusCode !== 200) {\n              this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Error, \"(LongPolling transport) Unexpected response code: \" + response.statusCode + \".\"); // Unexpected status code\n\n              this.closeError = new _Errors__WEBPACK_IMPORTED_MODULE_1__[\"HttpError\"](response.statusText || \"\", response.statusCode);\n              this.running = false;\n            } else {\n              // Process the response\n              if (response.content) {\n                this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Trace, \"(LongPolling transport) data received. \" + Object(_Utils__WEBPACK_IMPORTED_MODULE_4__[\"getDataDetail\"])(response.content, this.logMessageContent) + \".\");\n\n                if (this.onreceive) {\n                  this.onreceive(response.content);\n                }\n              } else {\n                // This is another way timeout manifest.\n                this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\n              }\n            }\n\n            return [3\n            /*break*/\n            , 6];\n\n          case 5:\n            e_1 = _a.sent();\n\n            if (!this.running) {\n              // Log but disregard errors that occur after stopping\n              this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Trace, \"(LongPolling transport) Poll errored after shutdown: \" + e_1.message);\n            } else {\n              if (e_1 instanceof _Errors__WEBPACK_IMPORTED_MODULE_1__[\"TimeoutError\"]) {\n                // Ignore timeouts and reissue the poll.\n                this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\n              } else {\n                // Close the connection with the error as the result.\n                this.closeError = e_1;\n                this.running = false;\n              }\n            }\n\n            return [3\n            /*break*/\n            , 6];\n\n          case 6:\n            return [3\n            /*break*/\n            , 1];\n\n          case 7:\n            return [3\n            /*break*/\n            , 9];\n\n          case 8:\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Trace, \"(LongPolling transport) Polling complete.\"); // We will reach here with pollAborted==false when the server returned a response causing the transport to stop.\n            // If pollAborted==true then client initiated the stop and the stop method will raise the close event after DELETE is sent.\n\n            if (!this.pollAborted) {\n              this.raiseOnClose();\n            }\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 9:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  LongPollingTransport.prototype.send = function (data) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        if (!this.running) {\n          return [2\n          /*return*/\n          , Promise.reject(new Error(\"Cannot send until the transport is connected\"))];\n        }\n\n        return [2\n        /*return*/\n        , Object(_Utils__WEBPACK_IMPORTED_MODULE_4__[\"sendMessage\"])(this.logger, \"LongPolling\", this.httpClient, this.url, this.accessTokenFactory, data, this.logMessageContent, this.withCredentials, this.headers)];\n      });\n    });\n  };\n\n  LongPollingTransport.prototype.stop = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var headers, _a, name_1, value, deleteOptions, token;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Trace, \"(LongPolling transport) Stopping polling.\"); // Tell receiving loop to stop, abort any current request, and then wait for it to finish\n\n            this.running = false;\n            this.pollAbort.abort();\n            _b.label = 1;\n\n          case 1:\n            _b.trys.push([1,, 5, 6]);\n\n            return [4\n            /*yield*/\n            , this.receiving];\n\n          case 2:\n            _b.sent(); // Send DELETE to clean up long polling on the server\n\n\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Trace, \"(LongPolling transport) sending DELETE request to \" + this.url + \".\");\n            headers = {};\n            _a = Object(_Utils__WEBPACK_IMPORTED_MODULE_4__[\"getUserAgentHeader\"])(), name_1 = _a[0], value = _a[1];\n            headers[name_1] = value;\n            deleteOptions = {\n              headers: __assign({}, headers, this.headers),\n              withCredentials: this.withCredentials\n            };\n            return [4\n            /*yield*/\n            , this.getAccessToken()];\n\n          case 3:\n            token = _b.sent();\n            this.updateHeaderToken(deleteOptions, token);\n            return [4\n            /*yield*/\n            , this.httpClient.delete(this.url, deleteOptions)];\n\n          case 4:\n            _b.sent();\n\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Trace, \"(LongPolling transport) DELETE request sent.\");\n            return [3\n            /*break*/\n            , 6];\n\n          case 5:\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Trace, \"(LongPolling transport) Stop finished.\"); // Raise close event here instead of in polling\n            // It needs to happen after the DELETE request is sent\n\n            this.raiseOnClose();\n            return [7\n            /*endfinally*/\n            ];\n\n          case 6:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  LongPollingTransport.prototype.raiseOnClose = function () {\n    if (this.onclose) {\n      var logMessage = \"(LongPolling transport) Firing onclose event.\";\n\n      if (this.closeError) {\n        logMessage += \" Error: \" + this.closeError;\n      }\n\n      this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Trace, logMessage);\n      this.onclose(this.closeError);\n    }\n  };\n\n  return LongPollingTransport;\n}();\n\n\n\n//# sourceURL=webpack:///./node_modules/@microsoft/signalr/dist/esm/LongPollingTransport.js?");

/***/ }),

/***/ "Id6e":
/*!*******************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/XhrHttpClient.js ***!
  \*******************************************************************/
/*! exports provided: XhrHttpClient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"XhrHttpClient\", function() { return XhrHttpClient; });\n/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Errors */ \"9BRb\");\n/* harmony import */ var _HttpClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HttpClient */ \"Rlqr\");\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ILogger */ \"M+GD\");\n// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\nvar __extends = undefined && undefined.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\n\n\n\n\nvar XhrHttpClient =\n/** @class */\nfunction (_super) {\n  __extends(XhrHttpClient, _super);\n\n  function XhrHttpClient(logger) {\n    var _this = _super.call(this) || this;\n\n    _this.logger = logger;\n    return _this;\n  }\n  /** @inheritDoc */\n\n\n  XhrHttpClient.prototype.send = function (request) {\n    var _this = this; // Check that abort was not signaled before calling send\n\n\n    if (request.abortSignal && request.abortSignal.aborted) {\n      return Promise.reject(new _Errors__WEBPACK_IMPORTED_MODULE_0__[\"AbortError\"]());\n    }\n\n    if (!request.method) {\n      return Promise.reject(new Error(\"No method defined.\"));\n    }\n\n    if (!request.url) {\n      return Promise.reject(new Error(\"No url defined.\"));\n    }\n\n    return new Promise(function (resolve, reject) {\n      var xhr = new XMLHttpRequest();\n      xhr.open(request.method, request.url, true);\n      xhr.withCredentials = request.withCredentials === undefined ? true : request.withCredentials;\n      xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\"); // Explicitly setting the Content-Type header for React Native on Android platform.\n\n      xhr.setRequestHeader(\"Content-Type\", \"text/plain;charset=UTF-8\");\n      var headers = request.headers;\n\n      if (headers) {\n        Object.keys(headers).forEach(function (header) {\n          xhr.setRequestHeader(header, headers[header]);\n        });\n      }\n\n      if (request.responseType) {\n        xhr.responseType = request.responseType;\n      }\n\n      if (request.abortSignal) {\n        request.abortSignal.onabort = function () {\n          xhr.abort();\n          reject(new _Errors__WEBPACK_IMPORTED_MODULE_0__[\"AbortError\"]());\n        };\n      }\n\n      if (request.timeout) {\n        xhr.timeout = request.timeout;\n      }\n\n      xhr.onload = function () {\n        if (request.abortSignal) {\n          request.abortSignal.onabort = null;\n        }\n\n        if (xhr.status >= 200 && xhr.status < 300) {\n          resolve(new _HttpClient__WEBPACK_IMPORTED_MODULE_1__[\"HttpResponse\"](xhr.status, xhr.statusText, xhr.response || xhr.responseText));\n        } else {\n          reject(new _Errors__WEBPACK_IMPORTED_MODULE_0__[\"HttpError\"](xhr.statusText, xhr.status));\n        }\n      };\n\n      xhr.onerror = function () {\n        _this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Warning, \"Error from HTTP request. \" + xhr.status + \": \" + xhr.statusText + \".\");\n\n        reject(new _Errors__WEBPACK_IMPORTED_MODULE_0__[\"HttpError\"](xhr.statusText, xhr.status));\n      };\n\n      xhr.ontimeout = function () {\n        _this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Warning, \"Timeout from HTTP request.\");\n\n        reject(new _Errors__WEBPACK_IMPORTED_MODULE_0__[\"TimeoutError\"]());\n      };\n\n      xhr.send(request.content || \"\");\n    });\n  };\n\n  return XhrHttpClient;\n}(_HttpClient__WEBPACK_IMPORTED_MODULE_1__[\"HttpClient\"]);\n\n\n\n//# sourceURL=webpack:///./node_modules/@microsoft/signalr/dist/esm/XhrHttpClient.js?");

/***/ }),

/***/ "M+GD":
/*!*************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/ILogger.js ***!
  \*************************************************************/
/*! exports provided: LogLevel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LogLevel\", function() { return LogLevel; });\n// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\n// These values are designed to match the ASP.NET Log Levels since that's the pattern we're emulating here.\n\n/** Indicates the severity of a log message.\r\n *\r\n * Log Levels are ordered in increasing severity. So `Debug` is more severe than `Trace`, etc.\r\n */\nvar LogLevel;\n\n(function (LogLevel) {\n  /** Log level for very low severity diagnostic messages. */\n  LogLevel[LogLevel[\"Trace\"] = 0] = \"Trace\";\n  /** Log level for low severity diagnostic messages. */\n\n  LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\n  /** Log level for informational diagnostic messages. */\n\n  LogLevel[LogLevel[\"Information\"] = 2] = \"Information\";\n  /** Log level for diagnostic messages that indicate a non-fatal problem. */\n\n  LogLevel[LogLevel[\"Warning\"] = 3] = \"Warning\";\n  /** Log level for diagnostic messages that indicate a failure in the current operation. */\n\n  LogLevel[LogLevel[\"Error\"] = 4] = \"Error\";\n  /** Log level for diagnostic messages that indicate a failure that will terminate the entire application. */\n\n  LogLevel[LogLevel[\"Critical\"] = 5] = \"Critical\";\n  /** The highest possible log level. Used when configuring logging to indicate that no log messages should be emitted. */\n\n  LogLevel[LogLevel[\"None\"] = 6] = \"None\";\n})(LogLevel || (LogLevel = {}));\n\n//# sourceURL=webpack:///./node_modules/@microsoft/signalr/dist/esm/ILogger.js?");

/***/ }),

/***/ "PMyv":
/*!***********************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/TextMessageFormat.js ***!
  \***********************************************************************/
/*! exports provided: TextMessageFormat */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextMessageFormat\", function() { return TextMessageFormat; });\n// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\n// Not exported from index\n\n/** @private */\nvar TextMessageFormat =\n/** @class */\nfunction () {\n  function TextMessageFormat() {}\n\n  TextMessageFormat.write = function (output) {\n    return \"\" + output + TextMessageFormat.RecordSeparator;\n  };\n\n  TextMessageFormat.parse = function (input) {\n    if (input[input.length - 1] !== TextMessageFormat.RecordSeparator) {\n      throw new Error(\"Message is incomplete.\");\n    }\n\n    var messages = input.split(TextMessageFormat.RecordSeparator);\n    messages.pop();\n    return messages;\n  };\n\n  TextMessageFormat.RecordSeparatorCode = 0x1e;\n  TextMessageFormat.RecordSeparator = String.fromCharCode(TextMessageFormat.RecordSeparatorCode);\n  return TextMessageFormat;\n}();\n\n\n\n//# sourceURL=webpack:///./node_modules/@microsoft/signalr/dist/esm/TextMessageFormat.js?");

/***/ }),

/***/ "Rlqr":
/*!****************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/HttpClient.js ***!
  \****************************************************************/
/*! exports provided: HttpResponse, HttpClient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HttpResponse\", function() { return HttpResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HttpClient\", function() { return HttpClient; });\n// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\nvar __assign = undefined && undefined.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n  }\n\n  return t;\n};\n/** Represents an HTTP response. */\n\n\nvar HttpResponse =\n/** @class */\nfunction () {\n  function HttpResponse(statusCode, statusText, content) {\n    this.statusCode = statusCode;\n    this.statusText = statusText;\n    this.content = content;\n  }\n\n  return HttpResponse;\n}();\n\n\n/** Abstraction over an HTTP client.\r\n *\r\n * This class provides an abstraction over an HTTP client so that a different implementation can be provided on different platforms.\r\n */\n\nvar HttpClient =\n/** @class */\nfunction () {\n  function HttpClient() {}\n\n  HttpClient.prototype.get = function (url, options) {\n    return this.send(__assign({}, options, {\n      method: \"GET\",\n      url: url\n    }));\n  };\n\n  HttpClient.prototype.post = function (url, options) {\n    return this.send(__assign({}, options, {\n      method: \"POST\",\n      url: url\n    }));\n  };\n\n  HttpClient.prototype.delete = function (url, options) {\n    return this.send(__assign({}, options, {\n      method: \"DELETE\",\n      url: url\n    }));\n  };\n  /** Gets all cookies that apply to the specified URL.\r\n   *\r\n   * @param url The URL that the cookies are valid for.\r\n   * @returns {string} A string containing all the key-value cookie pairs for the specified URL.\r\n   */\n  // @ts-ignore\n\n\n  HttpClient.prototype.getCookieString = function (url) {\n    return \"\";\n  };\n\n  return HttpClient;\n}();\n\n\n\n//# sourceURL=webpack:///./node_modules/@microsoft/signalr/dist/esm/HttpClient.js?");

/***/ }),

/***/ "Ysxs":
/*!***********************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/DefaultHttpClient.js ***!
  \***********************************************************************/
/*! exports provided: DefaultHttpClient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DefaultHttpClient\", function() { return DefaultHttpClient; });\n/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Errors */ \"9BRb\");\n/* harmony import */ var _FetchHttpClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FetchHttpClient */ \"1/4N\");\n/* harmony import */ var _HttpClient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HttpClient */ \"Rlqr\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Utils */ \"ftFU\");\n/* harmony import */ var _XhrHttpClient__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./XhrHttpClient */ \"Id6e\");\n// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\nvar __extends = undefined && undefined.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\n\n\n\n\n\n/** Default implementation of {@link @microsoft/signalr.HttpClient}. */\n\nvar DefaultHttpClient =\n/** @class */\nfunction (_super) {\n  __extends(DefaultHttpClient, _super);\n  /** Creates a new instance of the {@link @microsoft/signalr.DefaultHttpClient}, using the provided {@link @microsoft/signalr.ILogger} to log messages. */\n\n\n  function DefaultHttpClient(logger) {\n    var _this = _super.call(this) || this;\n\n    if (typeof fetch !== \"undefined\" || _Utils__WEBPACK_IMPORTED_MODULE_3__[\"Platform\"].isNode) {\n      _this.httpClient = new _FetchHttpClient__WEBPACK_IMPORTED_MODULE_1__[\"FetchHttpClient\"](logger);\n    } else if (typeof XMLHttpRequest !== \"undefined\") {\n      _this.httpClient = new _XhrHttpClient__WEBPACK_IMPORTED_MODULE_4__[\"XhrHttpClient\"](logger);\n    } else {\n      throw new Error(\"No usable HttpClient found.\");\n    }\n\n    return _this;\n  }\n  /** @inheritDoc */\n\n\n  DefaultHttpClient.prototype.send = function (request) {\n    // Check that abort was not signaled before calling send\n    if (request.abortSignal && request.abortSignal.aborted) {\n      return Promise.reject(new _Errors__WEBPACK_IMPORTED_MODULE_0__[\"AbortError\"]());\n    }\n\n    if (!request.method) {\n      return Promise.reject(new Error(\"No method defined.\"));\n    }\n\n    if (!request.url) {\n      return Promise.reject(new Error(\"No url defined.\"));\n    }\n\n    return this.httpClient.send(request);\n  };\n\n  DefaultHttpClient.prototype.getCookieString = function (url) {\n    return this.httpClient.getCookieString(url);\n  };\n\n  return DefaultHttpClient;\n}(_HttpClient__WEBPACK_IMPORTED_MODULE_2__[\"HttpClient\"]);\n\n\n\n//# sourceURL=webpack:///./node_modules/@microsoft/signalr/dist/esm/DefaultHttpClient.js?");

/***/ }),

/***/ "Z3rW":
/*!***********************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/HandshakeProtocol.js ***!
  \***********************************************************************/
/*! exports provided: HandshakeProtocol */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HandshakeProtocol\", function() { return HandshakeProtocol; });\n/* harmony import */ var _TextMessageFormat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TextMessageFormat */ \"PMyv\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils */ \"ftFU\");\n// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\n\n\n/** @private */\n\nvar HandshakeProtocol =\n/** @class */\nfunction () {\n  function HandshakeProtocol() {} // Handshake request is always JSON\n\n\n  HandshakeProtocol.prototype.writeHandshakeRequest = function (handshakeRequest) {\n    return _TextMessageFormat__WEBPACK_IMPORTED_MODULE_0__[\"TextMessageFormat\"].write(JSON.stringify(handshakeRequest));\n  };\n\n  HandshakeProtocol.prototype.parseHandshakeResponse = function (data) {\n    var responseMessage;\n    var messageData;\n    var remainingData;\n\n    if (Object(_Utils__WEBPACK_IMPORTED_MODULE_1__[\"isArrayBuffer\"])(data) || typeof Buffer !== \"undefined\" && data instanceof Buffer) {\n      // Format is binary but still need to read JSON text from handshake response\n      var binaryData = new Uint8Array(data);\n      var separatorIndex = binaryData.indexOf(_TextMessageFormat__WEBPACK_IMPORTED_MODULE_0__[\"TextMessageFormat\"].RecordSeparatorCode);\n\n      if (separatorIndex === -1) {\n        throw new Error(\"Message is incomplete.\");\n      } // content before separator is handshake response\n      // optional content after is additional messages\n\n\n      var responseLength = separatorIndex + 1;\n      messageData = String.fromCharCode.apply(null, binaryData.slice(0, responseLength));\n      remainingData = binaryData.byteLength > responseLength ? binaryData.slice(responseLength).buffer : null;\n    } else {\n      var textData = data;\n      var separatorIndex = textData.indexOf(_TextMessageFormat__WEBPACK_IMPORTED_MODULE_0__[\"TextMessageFormat\"].RecordSeparator);\n\n      if (separatorIndex === -1) {\n        throw new Error(\"Message is incomplete.\");\n      } // content before separator is handshake response\n      // optional content after is additional messages\n\n\n      var responseLength = separatorIndex + 1;\n      messageData = textData.substring(0, responseLength);\n      remainingData = textData.length > responseLength ? textData.substring(responseLength) : null;\n    } // At this point we should have just the single handshake message\n\n\n    var messages = _TextMessageFormat__WEBPACK_IMPORTED_MODULE_0__[\"TextMessageFormat\"].parse(messageData);\n    var response = JSON.parse(messages[0]);\n\n    if (response.type) {\n      throw new Error(\"Expected a handshake response from the server.\");\n    }\n\n    responseMessage = response; // multiple messages could have arrived with handshake\n    // return additional data to be parsed as usual, or null if all parsed\n\n    return [remainingData, responseMessage];\n  };\n\n  return HandshakeProtocol;\n}();\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../buffer/index.js */ \"tjlA\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/@microsoft/signalr/dist/esm/HandshakeProtocol.js?");

/***/ }),

/***/ "ftFU":
/*!***********************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/Utils.js ***!
  \***********************************************************/
/*! exports provided: VERSION, Arg, Platform, getDataDetail, formatArrayBuffer, isArrayBuffer, sendMessage, createLogger, SubjectSubscription, ConsoleLogger, getUserAgentHeader, constructUserAgent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VERSION\", function() { return VERSION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Arg\", function() { return Arg; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Platform\", function() { return Platform; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getDataDetail\", function() { return getDataDetail; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"formatArrayBuffer\", function() { return formatArrayBuffer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isArrayBuffer\", function() { return isArrayBuffer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sendMessage\", function() { return sendMessage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createLogger\", function() { return createLogger; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SubjectSubscription\", function() { return SubjectSubscription; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConsoleLogger\", function() { return ConsoleLogger; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getUserAgentHeader\", function() { return getUserAgentHeader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"constructUserAgent\", function() { return constructUserAgent; });\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ILogger */ \"M+GD\");\n/* harmony import */ var _Loggers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Loggers */ \"v3Fn\");\n// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\nvar __assign = undefined && undefined.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n  }\n\n  return t;\n};\n\nvar __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = undefined && undefined.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\n\n // Version token that will be replaced by the prepack command\n\n/** The version of the SignalR client. */\n\nvar VERSION = \"5.0.2\";\n/** @private */\n\nvar Arg =\n/** @class */\nfunction () {\n  function Arg() {}\n\n  Arg.isRequired = function (val, name) {\n    if (val === null || val === undefined) {\n      throw new Error(\"The '\" + name + \"' argument is required.\");\n    }\n  };\n\n  Arg.isNotEmpty = function (val, name) {\n    if (!val || val.match(/^\\s*$/)) {\n      throw new Error(\"The '\" + name + \"' argument should not be empty.\");\n    }\n  };\n\n  Arg.isIn = function (val, values, name) {\n    // TypeScript enums have keys for **both** the name and the value of each enum member on the type itself.\n    if (!(val in values)) {\n      throw new Error(\"Unknown \" + name + \" value: \" + val + \".\");\n    }\n  };\n\n  return Arg;\n}();\n\n\n/** @private */\n\nvar Platform =\n/** @class */\nfunction () {\n  function Platform() {}\n\n  Object.defineProperty(Platform, \"isBrowser\", {\n    get: function () {\n      return typeof window === \"object\";\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Platform, \"isWebWorker\", {\n    get: function () {\n      return typeof self === \"object\" && \"importScripts\" in self;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Platform, \"isNode\", {\n    get: function () {\n      return !this.isBrowser && !this.isWebWorker;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Platform;\n}();\n\n\n/** @private */\n\nfunction getDataDetail(data, includeContent) {\n  var detail = \"\";\n\n  if (isArrayBuffer(data)) {\n    detail = \"Binary data of length \" + data.byteLength;\n\n    if (includeContent) {\n      detail += \". Content: '\" + formatArrayBuffer(data) + \"'\";\n    }\n  } else if (typeof data === \"string\") {\n    detail = \"String data of length \" + data.length;\n\n    if (includeContent) {\n      detail += \". Content: '\" + data + \"'\";\n    }\n  }\n\n  return detail;\n}\n/** @private */\n\nfunction formatArrayBuffer(data) {\n  var view = new Uint8Array(data); // Uint8Array.map only supports returning another Uint8Array?\n\n  var str = \"\";\n  view.forEach(function (num) {\n    var pad = num < 16 ? \"0\" : \"\";\n    str += \"0x\" + pad + num.toString(16) + \" \";\n  }); // Trim of trailing space.\n\n  return str.substr(0, str.length - 1);\n} // Also in signalr-protocol-msgpack/Utils.ts\n\n/** @private */\n\nfunction isArrayBuffer(val) {\n  return val && typeof ArrayBuffer !== \"undefined\" && (val instanceof ArrayBuffer || // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof\n  val.constructor && val.constructor.name === \"ArrayBuffer\");\n}\n/** @private */\n\nfunction sendMessage(logger, transportName, httpClient, url, accessTokenFactory, content, logMessageContent, withCredentials, defaultHeaders) {\n  return __awaiter(this, void 0, void 0, function () {\n    var _a, headers, token, _b, name, value, responseType, response;\n\n    return __generator(this, function (_c) {\n      switch (_c.label) {\n        case 0:\n          headers = {};\n          if (!accessTokenFactory) return [3\n          /*break*/\n          , 2];\n          return [4\n          /*yield*/\n          , accessTokenFactory()];\n\n        case 1:\n          token = _c.sent();\n\n          if (token) {\n            headers = (_a = {}, _a[\"Authorization\"] = \"Bearer \" + token, _a);\n          }\n\n          _c.label = 2;\n\n        case 2:\n          _b = getUserAgentHeader(), name = _b[0], value = _b[1];\n          headers[name] = value;\n          logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__[\"LogLevel\"].Trace, \"(\" + transportName + \" transport) sending data. \" + getDataDetail(content, logMessageContent) + \".\");\n          responseType = isArrayBuffer(content) ? \"arraybuffer\" : \"text\";\n          return [4\n          /*yield*/\n          , httpClient.post(url, {\n            content: content,\n            headers: __assign({}, headers, defaultHeaders),\n            responseType: responseType,\n            withCredentials: withCredentials\n          })];\n\n        case 3:\n          response = _c.sent();\n          logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__[\"LogLevel\"].Trace, \"(\" + transportName + \" transport) request complete. Response status: \" + response.statusCode + \".\");\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n/** @private */\n\nfunction createLogger(logger) {\n  if (logger === undefined) {\n    return new ConsoleLogger(_ILogger__WEBPACK_IMPORTED_MODULE_0__[\"LogLevel\"].Information);\n  }\n\n  if (logger === null) {\n    return _Loggers__WEBPACK_IMPORTED_MODULE_1__[\"NullLogger\"].instance;\n  }\n\n  if (logger.log) {\n    return logger;\n  }\n\n  return new ConsoleLogger(logger);\n}\n/** @private */\n\nvar SubjectSubscription =\n/** @class */\nfunction () {\n  function SubjectSubscription(subject, observer) {\n    this.subject = subject;\n    this.observer = observer;\n  }\n\n  SubjectSubscription.prototype.dispose = function () {\n    var index = this.subject.observers.indexOf(this.observer);\n\n    if (index > -1) {\n      this.subject.observers.splice(index, 1);\n    }\n\n    if (this.subject.observers.length === 0 && this.subject.cancelCallback) {\n      this.subject.cancelCallback().catch(function (_) {});\n    }\n  };\n\n  return SubjectSubscription;\n}();\n\n\n/** @private */\n\nvar ConsoleLogger =\n/** @class */\nfunction () {\n  function ConsoleLogger(minimumLogLevel) {\n    this.minimumLogLevel = minimumLogLevel;\n    this.outputConsole = console;\n  }\n\n  ConsoleLogger.prototype.log = function (logLevel, message) {\n    if (logLevel >= this.minimumLogLevel) {\n      switch (logLevel) {\n        case _ILogger__WEBPACK_IMPORTED_MODULE_0__[\"LogLevel\"].Critical:\n        case _ILogger__WEBPACK_IMPORTED_MODULE_0__[\"LogLevel\"].Error:\n          this.outputConsole.error(\"[\" + new Date().toISOString() + \"] \" + _ILogger__WEBPACK_IMPORTED_MODULE_0__[\"LogLevel\"][logLevel] + \": \" + message);\n          break;\n\n        case _ILogger__WEBPACK_IMPORTED_MODULE_0__[\"LogLevel\"].Warning:\n          this.outputConsole.warn(\"[\" + new Date().toISOString() + \"] \" + _ILogger__WEBPACK_IMPORTED_MODULE_0__[\"LogLevel\"][logLevel] + \": \" + message);\n          break;\n\n        case _ILogger__WEBPACK_IMPORTED_MODULE_0__[\"LogLevel\"].Information:\n          this.outputConsole.info(\"[\" + new Date().toISOString() + \"] \" + _ILogger__WEBPACK_IMPORTED_MODULE_0__[\"LogLevel\"][logLevel] + \": \" + message);\n          break;\n\n        default:\n          // console.debug only goes to attached debuggers in Node, so we use console.log for Trace and Debug\n          this.outputConsole.log(\"[\" + new Date().toISOString() + \"] \" + _ILogger__WEBPACK_IMPORTED_MODULE_0__[\"LogLevel\"][logLevel] + \": \" + message);\n          break;\n      }\n    }\n  };\n\n  return ConsoleLogger;\n}();\n\n\n/** @private */\n\nfunction getUserAgentHeader() {\n  var userAgentHeaderName = \"X-SignalR-User-Agent\";\n\n  if (Platform.isNode) {\n    userAgentHeaderName = \"User-Agent\";\n  }\n\n  return [userAgentHeaderName, constructUserAgent(VERSION, getOsName(), getRuntime(), getRuntimeVersion())];\n}\n/** @private */\n\nfunction constructUserAgent(version, os, runtime, runtimeVersion) {\n  // Microsoft SignalR/[Version] ([Detailed Version]; [Operating System]; [Runtime]; [Runtime Version])\n  var userAgent = \"Microsoft SignalR/\";\n  var majorAndMinor = version.split(\".\");\n  userAgent += majorAndMinor[0] + \".\" + majorAndMinor[1];\n  userAgent += \" (\" + version + \"; \";\n\n  if (os && os !== \"\") {\n    userAgent += os + \"; \";\n  } else {\n    userAgent += \"Unknown OS; \";\n  }\n\n  userAgent += \"\" + runtime;\n\n  if (runtimeVersion) {\n    userAgent += \"; \" + runtimeVersion;\n  } else {\n    userAgent += \"; Unknown Runtime Version\";\n  }\n\n  userAgent += \")\";\n  return userAgent;\n}\n\nfunction getOsName() {\n  if (Platform.isNode) {\n    switch (process.platform) {\n      case \"win32\":\n        return \"Windows NT\";\n\n      case \"darwin\":\n        return \"macOS\";\n\n      case \"linux\":\n        return \"Linux\";\n\n      default:\n        return process.platform;\n    }\n  } else {\n    return \"\";\n  }\n}\n\nfunction getRuntimeVersion() {\n  if (Platform.isNode) {\n    return process.versions.node;\n  }\n\n  return undefined;\n}\n\nfunction getRuntime() {\n  if (Platform.isNode) {\n    return \"NodeJS\";\n  } else {\n    return \"Browser\";\n  }\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../process/browser.js */ \"8oxB\")))\n\n//# sourceURL=webpack:///./node_modules/@microsoft/signalr/dist/esm/Utils.js?");

/***/ }),

/***/ "k+Ty":
/*!****************************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/DefaultReconnectPolicy.js ***!
  \****************************************************************************/
/*! exports provided: DefaultReconnectPolicy */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DefaultReconnectPolicy\", function() { return DefaultReconnectPolicy; });\n// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\n// 0, 2, 10, 30 second delays before reconnect attempts.\nvar DEFAULT_RETRY_DELAYS_IN_MILLISECONDS = [0, 2000, 10000, 30000, null];\n/** @private */\n\nvar DefaultReconnectPolicy =\n/** @class */\nfunction () {\n  function DefaultReconnectPolicy(retryDelays) {\n    this.retryDelays = retryDelays !== undefined ? retryDelays.concat([null]) : DEFAULT_RETRY_DELAYS_IN_MILLISECONDS;\n  }\n\n  DefaultReconnectPolicy.prototype.nextRetryDelayInMilliseconds = function (retryContext) {\n    return this.retryDelays[retryContext.previousRetryCount];\n  };\n\n  return DefaultReconnectPolicy;\n}();\n\n\n\n//# sourceURL=webpack:///./node_modules/@microsoft/signalr/dist/esm/DefaultReconnectPolicy.js?");

/***/ }),

/***/ "mLhb":
/*!*******************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/HubConnection.js ***!
  \*******************************************************************/
/*! exports provided: HubConnectionState, HubConnection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HubConnectionState\", function() { return HubConnectionState; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HubConnection\", function() { return HubConnection; });\n/* harmony import */ var _HandshakeProtocol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HandshakeProtocol */ \"Z3rW\");\n/* harmony import */ var _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./IHubProtocol */ \"++1n\");\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ILogger */ \"M+GD\");\n/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Subject */ \"z2YZ\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Utils */ \"ftFU\");\n// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\nvar __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = undefined && undefined.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\n\n\n\n\n\nvar DEFAULT_TIMEOUT_IN_MS = 30 * 1000;\nvar DEFAULT_PING_INTERVAL_IN_MS = 15 * 1000;\n/** Describes the current state of the {@link HubConnection} to the server. */\n\nvar HubConnectionState;\n\n(function (HubConnectionState) {\n  /** The hub connection is disconnected. */\n  HubConnectionState[\"Disconnected\"] = \"Disconnected\";\n  /** The hub connection is connecting. */\n\n  HubConnectionState[\"Connecting\"] = \"Connecting\";\n  /** The hub connection is connected. */\n\n  HubConnectionState[\"Connected\"] = \"Connected\";\n  /** The hub connection is disconnecting. */\n\n  HubConnectionState[\"Disconnecting\"] = \"Disconnecting\";\n  /** The hub connection is reconnecting. */\n\n  HubConnectionState[\"Reconnecting\"] = \"Reconnecting\";\n})(HubConnectionState || (HubConnectionState = {}));\n/** Represents a connection to a SignalR Hub. */\n\n\nvar HubConnection =\n/** @class */\nfunction () {\n  function HubConnection(connection, logger, protocol, reconnectPolicy) {\n    var _this = this;\n\n    _Utils__WEBPACK_IMPORTED_MODULE_4__[\"Arg\"].isRequired(connection, \"connection\");\n    _Utils__WEBPACK_IMPORTED_MODULE_4__[\"Arg\"].isRequired(logger, \"logger\");\n    _Utils__WEBPACK_IMPORTED_MODULE_4__[\"Arg\"].isRequired(protocol, \"protocol\");\n    this.serverTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MS;\n    this.keepAliveIntervalInMilliseconds = DEFAULT_PING_INTERVAL_IN_MS;\n    this.logger = logger;\n    this.protocol = protocol;\n    this.connection = connection;\n    this.reconnectPolicy = reconnectPolicy;\n    this.handshakeProtocol = new _HandshakeProtocol__WEBPACK_IMPORTED_MODULE_0__[\"HandshakeProtocol\"]();\n\n    this.connection.onreceive = function (data) {\n      return _this.processIncomingData(data);\n    };\n\n    this.connection.onclose = function (error) {\n      return _this.connectionClosed(error);\n    };\n\n    this.callbacks = {};\n    this.methods = {};\n    this.closedCallbacks = [];\n    this.reconnectingCallbacks = [];\n    this.reconnectedCallbacks = [];\n    this.invocationId = 0;\n    this.receivedHandshakeResponse = false;\n    this.connectionState = HubConnectionState.Disconnected;\n    this.connectionStarted = false;\n    this.cachedPingMessage = this.protocol.writeMessage({\n      type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__[\"MessageType\"].Ping\n    });\n  }\n  /** @internal */\n  // Using a public static factory method means we can have a private constructor and an _internal_\n  // create method that can be used by HubConnectionBuilder. An \"internal\" constructor would just\n  // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a\n  // public parameter-less constructor.\n\n\n  HubConnection.create = function (connection, logger, protocol, reconnectPolicy) {\n    return new HubConnection(connection, logger, protocol, reconnectPolicy);\n  };\n\n  Object.defineProperty(HubConnection.prototype, \"state\", {\n    /** Indicates the state of the {@link HubConnection} to the server. */\n    get: function () {\n      return this.connectionState;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HubConnection.prototype, \"connectionId\", {\n    /** Represents the connection id of the {@link HubConnection} on the server. The connection id will be null when the connection is either\r\n     *  in the disconnected state or if the negotiation step was skipped.\r\n     */\n    get: function () {\n      return this.connection ? this.connection.connectionId || null : null;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HubConnection.prototype, \"baseUrl\", {\n    /** Indicates the url of the {@link HubConnection} to the server. */\n    get: function () {\n      return this.connection.baseUrl || \"\";\n    },\n\n    /**\r\n     * Sets a new url for the HubConnection. Note that the url can only be changed when the connection is in either the Disconnected or\r\n     * Reconnecting states.\r\n     * @param {string} url The url to connect to.\r\n     */\n    set: function (url) {\n      if (this.connectionState !== HubConnectionState.Disconnected && this.connectionState !== HubConnectionState.Reconnecting) {\n        throw new Error(\"The HubConnection must be in the Disconnected or Reconnecting state to change the url.\");\n      }\n\n      if (!url) {\n        throw new Error(\"The HubConnection url must be a valid url.\");\n      }\n\n      this.connection.baseUrl = url;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /** Starts the connection.\r\n   *\r\n   * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.\r\n   */\n\n  HubConnection.prototype.start = function () {\n    this.startPromise = this.startWithStateTransitions();\n    return this.startPromise;\n  };\n\n  HubConnection.prototype.startWithStateTransitions = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var e_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.connectionState !== HubConnectionState.Disconnected) {\n              return [2\n              /*return*/\n              , Promise.reject(new Error(\"Cannot start a HubConnection that is not in the 'Disconnected' state.\"))];\n            }\n\n            this.connectionState = HubConnectionState.Connecting;\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Debug, \"Starting HubConnection.\");\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.startInternal()];\n\n          case 2:\n            _a.sent();\n\n            this.connectionState = HubConnectionState.Connected;\n            this.connectionStarted = true;\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Debug, \"HubConnection connected successfully.\");\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            e_1 = _a.sent();\n            this.connectionState = HubConnectionState.Disconnected;\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Debug, \"HubConnection failed to start successfully because of error '\" + e_1 + \"'.\");\n            return [2\n            /*return*/\n            , Promise.reject(e_1)];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  HubConnection.prototype.startInternal = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var handshakePromise, handshakeRequest, e_2;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.stopDuringStartError = undefined;\n            this.receivedHandshakeResponse = false;\n            handshakePromise = new Promise(function (resolve, reject) {\n              _this.handshakeResolver = resolve;\n              _this.handshakeRejecter = reject;\n            });\n            return [4\n            /*yield*/\n            , this.connection.start(this.protocol.transferFormat)];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            _a.trys.push([2, 5,, 7]);\n\n            handshakeRequest = {\n              protocol: this.protocol.name,\n              version: this.protocol.version\n            };\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Debug, \"Sending handshake request.\");\n            return [4\n            /*yield*/\n            , this.sendMessage(this.handshakeProtocol.writeHandshakeRequest(handshakeRequest))];\n\n          case 3:\n            _a.sent();\n\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Information, \"Using HubProtocol '\" + this.protocol.name + \"'.\"); // defensively cleanup timeout in case we receive a message from the server before we finish start\n\n            this.cleanupTimeout();\n            this.resetTimeoutPeriod();\n            this.resetKeepAliveInterval();\n            return [4\n            /*yield*/\n            , handshakePromise];\n\n          case 4:\n            _a.sent(); // It's important to check the stopDuringStartError instead of just relying on the handshakePromise\n            // being rejected on close, because this continuation can run after both the handshake completed successfully\n            // and the connection was closed.\n\n\n            if (this.stopDuringStartError) {\n              // It's important to throw instead of returning a rejected promise, because we don't want to allow any state\n              // transitions to occur between now and the calling code observing the exceptions. Returning a rejected promise\n              // will cause the calling continuation to get scheduled to run later.\n              throw this.stopDuringStartError;\n            }\n\n            return [3\n            /*break*/\n            , 7];\n\n          case 5:\n            e_2 = _a.sent();\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Debug, \"Hub handshake failed with error '\" + e_2 + \"' during start(). Stopping HubConnection.\");\n            this.cleanupTimeout();\n            this.cleanupPingTimer(); // HttpConnection.stop() should not complete until after the onclose callback is invoked.\n            // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.\n\n            return [4\n            /*yield*/\n            , this.connection.stop(e_2)];\n\n          case 6:\n            // HttpConnection.stop() should not complete until after the onclose callback is invoked.\n            // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.\n            _a.sent();\n\n            throw e_2;\n\n          case 7:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /** Stops the connection.\r\n   *\r\n   * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.\r\n   */\n\n\n  HubConnection.prototype.stop = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var startPromise, e_3;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            startPromise = this.startPromise;\n            this.stopPromise = this.stopInternal();\n            return [4\n            /*yield*/\n            , this.stopPromise];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            _a.trys.push([2, 4,, 5]); // Awaiting undefined continues immediately\n\n\n            return [4\n            /*yield*/\n            , startPromise];\n\n          case 3:\n            // Awaiting undefined continues immediately\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 5];\n\n          case 4:\n            e_3 = _a.sent();\n            return [3\n            /*break*/\n            , 5];\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  HubConnection.prototype.stopInternal = function (error) {\n    if (this.connectionState === HubConnectionState.Disconnected) {\n      this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Debug, \"Call to HubConnection.stop(\" + error + \") ignored because it is already in the disconnected state.\");\n      return Promise.resolve();\n    }\n\n    if (this.connectionState === HubConnectionState.Disconnecting) {\n      this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Debug, \"Call to HttpConnection.stop(\" + error + \") ignored because the connection is already in the disconnecting state.\");\n      return this.stopPromise;\n    }\n\n    this.connectionState = HubConnectionState.Disconnecting;\n    this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Debug, \"Stopping HubConnection.\");\n\n    if (this.reconnectDelayHandle) {\n      // We're in a reconnect delay which means the underlying connection is currently already stopped.\n      // Just clear the handle to stop the reconnect loop (which no one is waiting on thankfully) and\n      // fire the onclose callbacks.\n      this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Debug, \"Connection stopped during reconnect delay. Done reconnecting.\");\n      clearTimeout(this.reconnectDelayHandle);\n      this.reconnectDelayHandle = undefined;\n      this.completeClose();\n      return Promise.resolve();\n    }\n\n    this.cleanupTimeout();\n    this.cleanupPingTimer();\n    this.stopDuringStartError = error || new Error(\"The connection was stopped before the hub handshake could complete.\"); // HttpConnection.stop() should not complete until after either HttpConnection.start() fails\n    // or the onclose callback is invoked. The onclose callback will transition the HubConnection\n    // to the disconnected state if need be before HttpConnection.stop() completes.\n\n    return this.connection.stop(error);\n  };\n  /** Invokes a streaming hub method on the server using the specified name and arguments.\r\n   *\r\n   * @typeparam T The type of the items returned by the server.\r\n   * @param {string} methodName The name of the server method to invoke.\r\n   * @param {any[]} args The arguments used to invoke the server method.\r\n   * @returns {IStreamResult<T>} An object that yields results from the server as they are received.\r\n   */\n\n\n  HubConnection.prototype.stream = function (methodName) {\n    var _this = this;\n\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    var _a = this.replaceStreamingParams(args),\n        streams = _a[0],\n        streamIds = _a[1];\n\n    var invocationDescriptor = this.createStreamInvocation(methodName, args, streamIds);\n    var promiseQueue;\n    var subject = new _Subject__WEBPACK_IMPORTED_MODULE_3__[\"Subject\"]();\n\n    subject.cancelCallback = function () {\n      var cancelInvocation = _this.createCancelInvocation(invocationDescriptor.invocationId);\n\n      delete _this.callbacks[invocationDescriptor.invocationId];\n      return promiseQueue.then(function () {\n        return _this.sendWithProtocol(cancelInvocation);\n      });\n    };\n\n    this.callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {\n      if (error) {\n        subject.error(error);\n        return;\n      } else if (invocationEvent) {\n        // invocationEvent will not be null when an error is not passed to the callback\n        if (invocationEvent.type === _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__[\"MessageType\"].Completion) {\n          if (invocationEvent.error) {\n            subject.error(new Error(invocationEvent.error));\n          } else {\n            subject.complete();\n          }\n        } else {\n          subject.next(invocationEvent.item);\n        }\n      }\n    };\n\n    promiseQueue = this.sendWithProtocol(invocationDescriptor).catch(function (e) {\n      subject.error(e);\n      delete _this.callbacks[invocationDescriptor.invocationId];\n    });\n    this.launchStreams(streams, promiseQueue);\n    return subject;\n  };\n\n  HubConnection.prototype.sendMessage = function (message) {\n    this.resetKeepAliveInterval();\n    return this.connection.send(message);\n  };\n  /**\r\n   * Sends a js object to the server.\r\n   * @param message The js object to serialize and send.\r\n   */\n\n\n  HubConnection.prototype.sendWithProtocol = function (message) {\n    return this.sendMessage(this.protocol.writeMessage(message));\n  };\n  /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.\r\n   *\r\n   * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still\r\n   * be processing the invocation.\r\n   *\r\n   * @param {string} methodName The name of the server method to invoke.\r\n   * @param {any[]} args The arguments used to invoke the server method.\r\n   * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.\r\n   */\n\n\n  HubConnection.prototype.send = function (methodName) {\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    var _a = this.replaceStreamingParams(args),\n        streams = _a[0],\n        streamIds = _a[1];\n\n    var sendPromise = this.sendWithProtocol(this.createInvocation(methodName, args, true, streamIds));\n    this.launchStreams(streams, sendPromise);\n    return sendPromise;\n  };\n  /** Invokes a hub method on the server using the specified name and arguments.\r\n   *\r\n   * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise\r\n   * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of\r\n   * resolving the Promise.\r\n   *\r\n   * @typeparam T The expected return type.\r\n   * @param {string} methodName The name of the server method to invoke.\r\n   * @param {any[]} args The arguments used to invoke the server method.\r\n   * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.\r\n   */\n\n\n  HubConnection.prototype.invoke = function (methodName) {\n    var _this = this;\n\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    var _a = this.replaceStreamingParams(args),\n        streams = _a[0],\n        streamIds = _a[1];\n\n    var invocationDescriptor = this.createInvocation(methodName, args, false, streamIds);\n    var p = new Promise(function (resolve, reject) {\n      // invocationId will always have a value for a non-blocking invocation\n      _this.callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {\n        if (error) {\n          reject(error);\n          return;\n        } else if (invocationEvent) {\n          // invocationEvent will not be null when an error is not passed to the callback\n          if (invocationEvent.type === _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__[\"MessageType\"].Completion) {\n            if (invocationEvent.error) {\n              reject(new Error(invocationEvent.error));\n            } else {\n              resolve(invocationEvent.result);\n            }\n          } else {\n            reject(new Error(\"Unexpected message type: \" + invocationEvent.type));\n          }\n        }\n      };\n\n      var promiseQueue = _this.sendWithProtocol(invocationDescriptor).catch(function (e) {\n        reject(e); // invocationId will always have a value for a non-blocking invocation\n\n        delete _this.callbacks[invocationDescriptor.invocationId];\n      });\n\n      _this.launchStreams(streams, promiseQueue);\n    });\n    return p;\n  };\n  /** Registers a handler that will be invoked when the hub method with the specified method name is invoked.\r\n   *\r\n   * @param {string} methodName The name of the hub method to define.\r\n   * @param {Function} newMethod The handler that will be raised when the hub method is invoked.\r\n   */\n\n\n  HubConnection.prototype.on = function (methodName, newMethod) {\n    if (!methodName || !newMethod) {\n      return;\n    }\n\n    methodName = methodName.toLowerCase();\n\n    if (!this.methods[methodName]) {\n      this.methods[methodName] = [];\n    } // Preventing adding the same handler multiple times.\n\n\n    if (this.methods[methodName].indexOf(newMethod) !== -1) {\n      return;\n    }\n\n    this.methods[methodName].push(newMethod);\n  };\n\n  HubConnection.prototype.off = function (methodName, method) {\n    if (!methodName) {\n      return;\n    }\n\n    methodName = methodName.toLowerCase();\n    var handlers = this.methods[methodName];\n\n    if (!handlers) {\n      return;\n    }\n\n    if (method) {\n      var removeIdx = handlers.indexOf(method);\n\n      if (removeIdx !== -1) {\n        handlers.splice(removeIdx, 1);\n\n        if (handlers.length === 0) {\n          delete this.methods[methodName];\n        }\n      }\n    } else {\n      delete this.methods[methodName];\n    }\n  };\n  /** Registers a handler that will be invoked when the connection is closed.\r\n   *\r\n   * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).\r\n   */\n\n\n  HubConnection.prototype.onclose = function (callback) {\n    if (callback) {\n      this.closedCallbacks.push(callback);\n    }\n  };\n  /** Registers a handler that will be invoked when the connection starts reconnecting.\r\n   *\r\n   * @param {Function} callback The handler that will be invoked when the connection starts reconnecting. Optionally receives a single argument containing the error that caused the connection to start reconnecting (if any).\r\n   */\n\n\n  HubConnection.prototype.onreconnecting = function (callback) {\n    if (callback) {\n      this.reconnectingCallbacks.push(callback);\n    }\n  };\n  /** Registers a handler that will be invoked when the connection successfully reconnects.\r\n   *\r\n   * @param {Function} callback The handler that will be invoked when the connection successfully reconnects.\r\n   */\n\n\n  HubConnection.prototype.onreconnected = function (callback) {\n    if (callback) {\n      this.reconnectedCallbacks.push(callback);\n    }\n  };\n\n  HubConnection.prototype.processIncomingData = function (data) {\n    this.cleanupTimeout();\n\n    if (!this.receivedHandshakeResponse) {\n      data = this.processHandshakeResponse(data);\n      this.receivedHandshakeResponse = true;\n    } // Data may have all been read when processing handshake response\n\n\n    if (data) {\n      // Parse the messages\n      var messages = this.protocol.parseMessages(data, this.logger);\n\n      for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {\n        var message = messages_1[_i];\n\n        switch (message.type) {\n          case _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__[\"MessageType\"].Invocation:\n            this.invokeClientMethod(message);\n            break;\n\n          case _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__[\"MessageType\"].StreamItem:\n          case _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__[\"MessageType\"].Completion:\n            var callback = this.callbacks[message.invocationId];\n\n            if (callback) {\n              if (message.type === _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__[\"MessageType\"].Completion) {\n                delete this.callbacks[message.invocationId];\n              }\n\n              callback(message);\n            }\n\n            break;\n\n          case _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__[\"MessageType\"].Ping:\n            // Don't care about pings\n            break;\n\n          case _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__[\"MessageType\"].Close:\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Information, \"Close message received from server.\");\n            var error = message.error ? new Error(\"Server returned an error on close: \" + message.error) : undefined;\n\n            if (message.allowReconnect === true) {\n              // It feels wrong not to await connection.stop() here, but processIncomingData is called as part of an onreceive callback which is not async,\n              // this is already the behavior for serverTimeout(), and HttpConnection.Stop() should catch and log all possible exceptions.\n              // tslint:disable-next-line:no-floating-promises\n              this.connection.stop(error);\n            } else {\n              // We cannot await stopInternal() here, but subsequent calls to stop() will await this if stopInternal() is still ongoing.\n              this.stopPromise = this.stopInternal(error);\n            }\n\n            break;\n\n          default:\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Warning, \"Invalid message type: \" + message.type + \".\");\n            break;\n        }\n      }\n    }\n\n    this.resetTimeoutPeriod();\n  };\n\n  HubConnection.prototype.processHandshakeResponse = function (data) {\n    var _a;\n\n    var responseMessage;\n    var remainingData;\n\n    try {\n      _a = this.handshakeProtocol.parseHandshakeResponse(data), remainingData = _a[0], responseMessage = _a[1];\n    } catch (e) {\n      var message = \"Error parsing handshake response: \" + e;\n      this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Error, message);\n      var error = new Error(message);\n      this.handshakeRejecter(error);\n      throw error;\n    }\n\n    if (responseMessage.error) {\n      var message = \"Server returned handshake error: \" + responseMessage.error;\n      this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Error, message);\n      var error = new Error(message);\n      this.handshakeRejecter(error);\n      throw error;\n    } else {\n      this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Debug, \"Server handshake complete.\");\n    }\n\n    this.handshakeResolver();\n    return remainingData;\n  };\n\n  HubConnection.prototype.resetKeepAliveInterval = function () {\n    var _this = this;\n\n    if (this.connection.features.inherentKeepAlive) {\n      return;\n    }\n\n    this.cleanupPingTimer();\n    this.pingServerHandle = setTimeout(function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _a;\n\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              if (!(this.connectionState === HubConnectionState.Connected)) return [3\n              /*break*/\n              , 4];\n              _b.label = 1;\n\n            case 1:\n              _b.trys.push([1, 3,, 4]);\n\n              return [4\n              /*yield*/\n              , this.sendMessage(this.cachedPingMessage)];\n\n            case 2:\n              _b.sent();\n\n              return [3\n              /*break*/\n              , 4];\n\n            case 3:\n              _a = _b.sent(); // We don't care about the error. It should be seen elsewhere in the client.\n              // The connection is probably in a bad or closed state now, cleanup the timer so it stops triggering\n\n              this.cleanupPingTimer();\n              return [3\n              /*break*/\n              , 4];\n\n            case 4:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }, this.keepAliveIntervalInMilliseconds);\n  };\n\n  HubConnection.prototype.resetTimeoutPeriod = function () {\n    var _this = this;\n\n    if (!this.connection.features || !this.connection.features.inherentKeepAlive) {\n      // Set the timeout timer\n      this.timeoutHandle = setTimeout(function () {\n        return _this.serverTimeout();\n      }, this.serverTimeoutInMilliseconds);\n    }\n  };\n\n  HubConnection.prototype.serverTimeout = function () {\n    // The server hasn't talked to us in a while. It doesn't like us anymore ... :(\n    // Terminate the connection, but we don't need to wait on the promise. This could trigger reconnecting.\n    // tslint:disable-next-line:no-floating-promises\n    this.connection.stop(new Error(\"Server timeout elapsed without receiving a message from the server.\"));\n  };\n\n  HubConnection.prototype.invokeClientMethod = function (invocationMessage) {\n    var _this = this;\n\n    var methods = this.methods[invocationMessage.target.toLowerCase()];\n\n    if (methods) {\n      try {\n        methods.forEach(function (m) {\n          return m.apply(_this, invocationMessage.arguments);\n        });\n      } catch (e) {\n        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Error, \"A callback for the method \" + invocationMessage.target.toLowerCase() + \" threw error '\" + e + \"'.\");\n      }\n\n      if (invocationMessage.invocationId) {\n        // This is not supported in v1. So we return an error to avoid blocking the server waiting for the response.\n        var message = \"Server requested a response, which is not supported in this version of the client.\";\n        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Error, message); // We don't want to wait on the stop itself.\n\n        this.stopPromise = this.stopInternal(new Error(message));\n      }\n    } else {\n      this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Warning, \"No client method with the name '\" + invocationMessage.target + \"' found.\");\n    }\n  };\n\n  HubConnection.prototype.connectionClosed = function (error) {\n    this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Debug, \"HubConnection.connectionClosed(\" + error + \") called while in state \" + this.connectionState + \".\"); // Triggering this.handshakeRejecter is insufficient because it could already be resolved without the continuation having run yet.\n\n    this.stopDuringStartError = this.stopDuringStartError || error || new Error(\"The underlying connection was closed before the hub handshake could complete.\"); // If the handshake is in progress, start will be waiting for the handshake promise, so we complete it.\n    // If it has already completed, this should just noop.\n\n    if (this.handshakeResolver) {\n      this.handshakeResolver();\n    }\n\n    this.cancelCallbacksWithError(error || new Error(\"Invocation canceled due to the underlying connection being closed.\"));\n    this.cleanupTimeout();\n    this.cleanupPingTimer();\n\n    if (this.connectionState === HubConnectionState.Disconnecting) {\n      this.completeClose(error);\n    } else if (this.connectionState === HubConnectionState.Connected && this.reconnectPolicy) {\n      // tslint:disable-next-line:no-floating-promises\n      this.reconnect(error);\n    } else if (this.connectionState === HubConnectionState.Connected) {\n      this.completeClose(error);\n    } // If none of the above if conditions were true were called the HubConnection must be in either:\n    // 1. The Connecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail it.\n    // 2. The Reconnecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail the current reconnect attempt\n    //    and potentially continue the reconnect() loop.\n    // 3. The Disconnected state in which case we're already done.\n\n  };\n\n  HubConnection.prototype.completeClose = function (error) {\n    var _this = this;\n\n    if (this.connectionStarted) {\n      this.connectionState = HubConnectionState.Disconnected;\n      this.connectionStarted = false;\n\n      try {\n        this.closedCallbacks.forEach(function (c) {\n          return c.apply(_this, [error]);\n        });\n      } catch (e) {\n        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Error, \"An onclose callback called with error '\" + error + \"' threw error '\" + e + \"'.\");\n      }\n    }\n  };\n\n  HubConnection.prototype.reconnect = function (error) {\n    return __awaiter(this, void 0, void 0, function () {\n      var reconnectStartTime, previousReconnectAttempts, retryError, nextRetryDelay, e_4;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            reconnectStartTime = Date.now();\n            previousReconnectAttempts = 0;\n            retryError = error !== undefined ? error : new Error(\"Attempting to reconnect due to a unknown error.\");\n            nextRetryDelay = this.getNextRetryDelay(previousReconnectAttempts++, 0, retryError);\n\n            if (nextRetryDelay === null) {\n              this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Debug, \"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt.\");\n              this.completeClose(error);\n              return [2\n              /*return*/\n              ];\n            }\n\n            this.connectionState = HubConnectionState.Reconnecting;\n\n            if (error) {\n              this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Information, \"Connection reconnecting because of error '\" + error + \"'.\");\n            } else {\n              this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Information, \"Connection reconnecting.\");\n            }\n\n            if (this.onreconnecting) {\n              try {\n                this.reconnectingCallbacks.forEach(function (c) {\n                  return c.apply(_this, [error]);\n                });\n              } catch (e) {\n                this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Error, \"An onreconnecting callback called with error '\" + error + \"' threw error '\" + e + \"'.\");\n              } // Exit early if an onreconnecting callback called connection.stop().\n\n\n              if (this.connectionState !== HubConnectionState.Reconnecting) {\n                this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Debug, \"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.\");\n                return [2\n                /*return*/\n                ];\n              }\n            }\n\n            _a.label = 1;\n\n          case 1:\n            if (!(nextRetryDelay !== null)) return [3\n            /*break*/\n            , 7];\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Information, \"Reconnect attempt number \" + previousReconnectAttempts + \" will start in \" + nextRetryDelay + \" ms.\");\n            return [4\n            /*yield*/\n            , new Promise(function (resolve) {\n              _this.reconnectDelayHandle = setTimeout(resolve, nextRetryDelay);\n            })];\n\n          case 2:\n            _a.sent();\n\n            this.reconnectDelayHandle = undefined;\n\n            if (this.connectionState !== HubConnectionState.Reconnecting) {\n              this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Debug, \"Connection left the reconnecting state during reconnect delay. Done reconnecting.\");\n              return [2\n              /*return*/\n              ];\n            }\n\n            _a.label = 3;\n\n          case 3:\n            _a.trys.push([3, 5,, 6]);\n\n            return [4\n            /*yield*/\n            , this.startInternal()];\n\n          case 4:\n            _a.sent();\n\n            this.connectionState = HubConnectionState.Connected;\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Information, \"HubConnection reconnected successfully.\");\n\n            if (this.onreconnected) {\n              try {\n                this.reconnectedCallbacks.forEach(function (c) {\n                  return c.apply(_this, [_this.connection.connectionId]);\n                });\n              } catch (e) {\n                this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Error, \"An onreconnected callback called with connectionId '\" + this.connection.connectionId + \"; threw error '\" + e + \"'.\");\n              }\n            }\n\n            return [2\n            /*return*/\n            ];\n\n          case 5:\n            e_4 = _a.sent();\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Information, \"Reconnect attempt failed because of error '\" + e_4 + \"'.\");\n\n            if (this.connectionState !== HubConnectionState.Reconnecting) {\n              this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Debug, \"Connection left the reconnecting state during reconnect attempt. Done reconnecting.\");\n              return [2\n              /*return*/\n              ];\n            }\n\n            retryError = e_4 instanceof Error ? e_4 : new Error(e_4.toString());\n            nextRetryDelay = this.getNextRetryDelay(previousReconnectAttempts++, Date.now() - reconnectStartTime, retryError);\n            return [3\n            /*break*/\n            , 6];\n\n          case 6:\n            return [3\n            /*break*/\n            , 1];\n\n          case 7:\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Information, \"Reconnect retries have been exhausted after \" + (Date.now() - reconnectStartTime) + \" ms and \" + previousReconnectAttempts + \" failed attempts. Connection disconnecting.\");\n            this.completeClose();\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  HubConnection.prototype.getNextRetryDelay = function (previousRetryCount, elapsedMilliseconds, retryReason) {\n    try {\n      return this.reconnectPolicy.nextRetryDelayInMilliseconds({\n        elapsedMilliseconds: elapsedMilliseconds,\n        previousRetryCount: previousRetryCount,\n        retryReason: retryReason\n      });\n    } catch (e) {\n      this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Error, \"IRetryPolicy.nextRetryDelayInMilliseconds(\" + previousRetryCount + \", \" + elapsedMilliseconds + \") threw error '\" + e + \"'.\");\n      return null;\n    }\n  };\n\n  HubConnection.prototype.cancelCallbacksWithError = function (error) {\n    var callbacks = this.callbacks;\n    this.callbacks = {};\n    Object.keys(callbacks).forEach(function (key) {\n      var callback = callbacks[key];\n      callback(null, error);\n    });\n  };\n\n  HubConnection.prototype.cleanupPingTimer = function () {\n    if (this.pingServerHandle) {\n      clearTimeout(this.pingServerHandle);\n    }\n  };\n\n  HubConnection.prototype.cleanupTimeout = function () {\n    if (this.timeoutHandle) {\n      clearTimeout(this.timeoutHandle);\n    }\n  };\n\n  HubConnection.prototype.createInvocation = function (methodName, args, nonblocking, streamIds) {\n    if (nonblocking) {\n      if (streamIds.length !== 0) {\n        return {\n          arguments: args,\n          streamIds: streamIds,\n          target: methodName,\n          type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__[\"MessageType\"].Invocation\n        };\n      } else {\n        return {\n          arguments: args,\n          target: methodName,\n          type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__[\"MessageType\"].Invocation\n        };\n      }\n    } else {\n      var invocationId = this.invocationId;\n      this.invocationId++;\n\n      if (streamIds.length !== 0) {\n        return {\n          arguments: args,\n          invocationId: invocationId.toString(),\n          streamIds: streamIds,\n          target: methodName,\n          type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__[\"MessageType\"].Invocation\n        };\n      } else {\n        return {\n          arguments: args,\n          invocationId: invocationId.toString(),\n          target: methodName,\n          type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__[\"MessageType\"].Invocation\n        };\n      }\n    }\n  };\n\n  HubConnection.prototype.launchStreams = function (streams, promiseQueue) {\n    var _this = this;\n\n    if (streams.length === 0) {\n      return;\n    } // Synchronize stream data so they arrive in-order on the server\n\n\n    if (!promiseQueue) {\n      promiseQueue = Promise.resolve();\n    }\n\n    var _loop_1 = function (streamId) {\n      streams[streamId].subscribe({\n        complete: function () {\n          promiseQueue = promiseQueue.then(function () {\n            return _this.sendWithProtocol(_this.createCompletionMessage(streamId));\n          });\n        },\n        error: function (err) {\n          var message;\n\n          if (err instanceof Error) {\n            message = err.message;\n          } else if (err && err.toString) {\n            message = err.toString();\n          } else {\n            message = \"Unknown error\";\n          }\n\n          promiseQueue = promiseQueue.then(function () {\n            return _this.sendWithProtocol(_this.createCompletionMessage(streamId, message));\n          });\n        },\n        next: function (item) {\n          promiseQueue = promiseQueue.then(function () {\n            return _this.sendWithProtocol(_this.createStreamItemMessage(streamId, item));\n          });\n        }\n      });\n    }; // We want to iterate over the keys, since the keys are the stream ids\n    // tslint:disable-next-line:forin\n\n\n    for (var streamId in streams) {\n      _loop_1(streamId);\n    }\n  };\n\n  HubConnection.prototype.replaceStreamingParams = function (args) {\n    var streams = [];\n    var streamIds = [];\n\n    for (var i = 0; i < args.length; i++) {\n      var argument = args[i];\n\n      if (this.isObservable(argument)) {\n        var streamId = this.invocationId;\n        this.invocationId++; // Store the stream for later use\n\n        streams[streamId] = argument;\n        streamIds.push(streamId.toString()); // remove stream from args\n\n        args.splice(i, 1);\n      }\n    }\n\n    return [streams, streamIds];\n  };\n\n  HubConnection.prototype.isObservable = function (arg) {\n    // This allows other stream implementations to just work (like rxjs)\n    return arg && arg.subscribe && typeof arg.subscribe === \"function\";\n  };\n\n  HubConnection.prototype.createStreamInvocation = function (methodName, args, streamIds) {\n    var invocationId = this.invocationId;\n    this.invocationId++;\n\n    if (streamIds.length !== 0) {\n      return {\n        arguments: args,\n        invocationId: invocationId.toString(),\n        streamIds: streamIds,\n        target: methodName,\n        type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__[\"MessageType\"].StreamInvocation\n      };\n    } else {\n      return {\n        arguments: args,\n        invocationId: invocationId.toString(),\n        target: methodName,\n        type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__[\"MessageType\"].StreamInvocation\n      };\n    }\n  };\n\n  HubConnection.prototype.createCancelInvocation = function (id) {\n    return {\n      invocationId: id,\n      type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__[\"MessageType\"].CancelInvocation\n    };\n  };\n\n  HubConnection.prototype.createStreamItemMessage = function (id, item) {\n    return {\n      invocationId: id,\n      item: item,\n      type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__[\"MessageType\"].StreamItem\n    };\n  };\n\n  HubConnection.prototype.createCompletionMessage = function (id, error, result) {\n    if (error) {\n      return {\n        error: error,\n        invocationId: id,\n        type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__[\"MessageType\"].Completion\n      };\n    }\n\n    return {\n      invocationId: id,\n      result: result,\n      type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_1__[\"MessageType\"].Completion\n    };\n  };\n\n  return HubConnection;\n}();\n\n\n\n//# sourceURL=webpack:///./node_modules/@microsoft/signalr/dist/esm/HubConnection.js?");

/***/ }),

/***/ "qFkC":
/*!****************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/ITransport.js ***!
  \****************************************************************/
/*! exports provided: HttpTransportType, TransferFormat */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HttpTransportType\", function() { return HttpTransportType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TransferFormat\", function() { return TransferFormat; });\n// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\n// This will be treated as a bit flag in the future, so we keep it using power-of-two values.\n\n/** Specifies a specific HTTP transport type. */\nvar HttpTransportType;\n\n(function (HttpTransportType) {\n  /** Specifies no transport preference. */\n  HttpTransportType[HttpTransportType[\"None\"] = 0] = \"None\";\n  /** Specifies the WebSockets transport. */\n\n  HttpTransportType[HttpTransportType[\"WebSockets\"] = 1] = \"WebSockets\";\n  /** Specifies the Server-Sent Events transport. */\n\n  HttpTransportType[HttpTransportType[\"ServerSentEvents\"] = 2] = \"ServerSentEvents\";\n  /** Specifies the Long Polling transport. */\n\n  HttpTransportType[HttpTransportType[\"LongPolling\"] = 4] = \"LongPolling\";\n})(HttpTransportType || (HttpTransportType = {}));\n/** Specifies the transfer format for a connection. */\n\n\nvar TransferFormat;\n\n(function (TransferFormat) {\n  /** Specifies that only text data will be transmitted over the connection. */\n  TransferFormat[TransferFormat[\"Text\"] = 1] = \"Text\";\n  /** Specifies that binary data will be transmitted over the connection. */\n\n  TransferFormat[TransferFormat[\"Binary\"] = 2] = \"Binary\";\n})(TransferFormat || (TransferFormat = {}));\n\n//# sourceURL=webpack:///./node_modules/@microsoft/signalr/dist/esm/ITransport.js?");

/***/ }),

/***/ "qIXe":
/*!*******************************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/ServerSentEventsTransport.js ***!
  \*******************************************************************************/
/*! exports provided: ServerSentEventsTransport */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ServerSentEventsTransport\", function() { return ServerSentEventsTransport; });\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ILogger */ \"M+GD\");\n/* harmony import */ var _ITransport__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ITransport */ \"qFkC\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utils */ \"ftFU\");\n// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\nvar __assign = undefined && undefined.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n  }\n\n  return t;\n};\n\nvar __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = undefined && undefined.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\n\n\n\n/** @private */\n\nvar ServerSentEventsTransport =\n/** @class */\nfunction () {\n  function ServerSentEventsTransport(httpClient, accessTokenFactory, logger, logMessageContent, eventSourceConstructor, withCredentials, headers) {\n    this.httpClient = httpClient;\n    this.accessTokenFactory = accessTokenFactory;\n    this.logger = logger;\n    this.logMessageContent = logMessageContent;\n    this.withCredentials = withCredentials;\n    this.eventSourceConstructor = eventSourceConstructor;\n    this.headers = headers;\n    this.onreceive = null;\n    this.onclose = null;\n  }\n\n  ServerSentEventsTransport.prototype.connect = function (url, transferFormat) {\n    return __awaiter(this, void 0, void 0, function () {\n      var token;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _Utils__WEBPACK_IMPORTED_MODULE_2__[\"Arg\"].isRequired(url, \"url\");\n            _Utils__WEBPACK_IMPORTED_MODULE_2__[\"Arg\"].isRequired(transferFormat, \"transferFormat\");\n            _Utils__WEBPACK_IMPORTED_MODULE_2__[\"Arg\"].isIn(transferFormat, _ITransport__WEBPACK_IMPORTED_MODULE_1__[\"TransferFormat\"], \"transferFormat\");\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__[\"LogLevel\"].Trace, \"(SSE transport) Connecting.\"); // set url before accessTokenFactory because this.url is only for send and we set the auth header instead of the query string for send\n\n            this.url = url;\n            if (!this.accessTokenFactory) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.accessTokenFactory()];\n\n          case 1:\n            token = _a.sent();\n\n            if (token) {\n              url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + (\"access_token=\" + encodeURIComponent(token));\n            }\n\n            _a.label = 2;\n\n          case 2:\n            return [2\n            /*return*/\n            , new Promise(function (resolve, reject) {\n              var opened = false;\n\n              if (transferFormat !== _ITransport__WEBPACK_IMPORTED_MODULE_1__[\"TransferFormat\"].Text) {\n                reject(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\n                return;\n              }\n\n              var eventSource;\n\n              if (_Utils__WEBPACK_IMPORTED_MODULE_2__[\"Platform\"].isBrowser || _Utils__WEBPACK_IMPORTED_MODULE_2__[\"Platform\"].isWebWorker) {\n                eventSource = new _this.eventSourceConstructor(url, {\n                  withCredentials: _this.withCredentials\n                });\n              } else {\n                // Non-browser passes cookies via the dictionary\n                var cookies = _this.httpClient.getCookieString(url);\n\n                var headers = {};\n                headers.Cookie = cookies;\n\n                var _a = Object(_Utils__WEBPACK_IMPORTED_MODULE_2__[\"getUserAgentHeader\"])(),\n                    name_1 = _a[0],\n                    value = _a[1];\n\n                headers[name_1] = value;\n                eventSource = new _this.eventSourceConstructor(url, {\n                  withCredentials: _this.withCredentials,\n                  headers: __assign({}, headers, _this.headers)\n                });\n              }\n\n              try {\n                eventSource.onmessage = function (e) {\n                  if (_this.onreceive) {\n                    try {\n                      _this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__[\"LogLevel\"].Trace, \"(SSE transport) data received. \" + Object(_Utils__WEBPACK_IMPORTED_MODULE_2__[\"getDataDetail\"])(e.data, _this.logMessageContent) + \".\");\n\n                      _this.onreceive(e.data);\n                    } catch (error) {\n                      _this.close(error);\n\n                      return;\n                    }\n                  }\n                };\n\n                eventSource.onerror = function (e) {\n                  var error = new Error(e.data || \"Error occurred\");\n\n                  if (opened) {\n                    _this.close(error);\n                  } else {\n                    reject(error);\n                  }\n                };\n\n                eventSource.onopen = function () {\n                  _this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__[\"LogLevel\"].Information, \"SSE connected to \" + _this.url);\n\n                  _this.eventSource = eventSource;\n                  opened = true;\n                  resolve();\n                };\n              } catch (e) {\n                reject(e);\n                return;\n              }\n            })];\n        }\n      });\n    });\n  };\n\n  ServerSentEventsTransport.prototype.send = function (data) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        if (!this.eventSource) {\n          return [2\n          /*return*/\n          , Promise.reject(new Error(\"Cannot send until the transport is connected\"))];\n        }\n\n        return [2\n        /*return*/\n        , Object(_Utils__WEBPACK_IMPORTED_MODULE_2__[\"sendMessage\"])(this.logger, \"SSE\", this.httpClient, this.url, this.accessTokenFactory, data, this.logMessageContent, this.withCredentials, this.headers)];\n      });\n    });\n  };\n\n  ServerSentEventsTransport.prototype.stop = function () {\n    this.close();\n    return Promise.resolve();\n  };\n\n  ServerSentEventsTransport.prototype.close = function (e) {\n    if (this.eventSource) {\n      this.eventSource.close();\n      this.eventSource = undefined;\n\n      if (this.onclose) {\n        this.onclose(e);\n      }\n    }\n  };\n\n  return ServerSentEventsTransport;\n}();\n\n\n\n//# sourceURL=webpack:///./node_modules/@microsoft/signalr/dist/esm/ServerSentEventsTransport.js?");

/***/ }),

/***/ "utQ/":
/*!**************************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/HubConnectionBuilder.js ***!
  \**************************************************************************/
/*! exports provided: HubConnectionBuilder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HubConnectionBuilder\", function() { return HubConnectionBuilder; });\n/* harmony import */ var _DefaultReconnectPolicy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultReconnectPolicy */ \"k+Ty\");\n/* harmony import */ var _HttpConnection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HttpConnection */ \"2lgH\");\n/* harmony import */ var _HubConnection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HubConnection */ \"mLhb\");\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ILogger */ \"M+GD\");\n/* harmony import */ var _JsonHubProtocol__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./JsonHubProtocol */ \"2zAs\");\n/* harmony import */ var _Loggers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Loggers */ \"v3Fn\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Utils */ \"ftFU\");\n// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\nvar __assign = undefined && undefined.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n  }\n\n  return t;\n};\n\n\n\n\n\n\n\n // tslint:disable:object-literal-sort-keys\n\nvar LogLevelNameMapping = {\n  trace: _ILogger__WEBPACK_IMPORTED_MODULE_3__[\"LogLevel\"].Trace,\n  debug: _ILogger__WEBPACK_IMPORTED_MODULE_3__[\"LogLevel\"].Debug,\n  info: _ILogger__WEBPACK_IMPORTED_MODULE_3__[\"LogLevel\"].Information,\n  information: _ILogger__WEBPACK_IMPORTED_MODULE_3__[\"LogLevel\"].Information,\n  warn: _ILogger__WEBPACK_IMPORTED_MODULE_3__[\"LogLevel\"].Warning,\n  warning: _ILogger__WEBPACK_IMPORTED_MODULE_3__[\"LogLevel\"].Warning,\n  error: _ILogger__WEBPACK_IMPORTED_MODULE_3__[\"LogLevel\"].Error,\n  critical: _ILogger__WEBPACK_IMPORTED_MODULE_3__[\"LogLevel\"].Critical,\n  none: _ILogger__WEBPACK_IMPORTED_MODULE_3__[\"LogLevel\"].None\n};\n\nfunction parseLogLevel(name) {\n  // Case-insensitive matching via lower-casing\n  // Yes, I know case-folding is a complicated problem in Unicode, but we only support\n  // the ASCII strings defined in LogLevelNameMapping anyway, so it's fine -anurse.\n  var mapping = LogLevelNameMapping[name.toLowerCase()];\n\n  if (typeof mapping !== \"undefined\") {\n    return mapping;\n  } else {\n    throw new Error(\"Unknown log level: \" + name);\n  }\n}\n/** A builder for configuring {@link @microsoft/signalr.HubConnection} instances. */\n\n\nvar HubConnectionBuilder =\n/** @class */\nfunction () {\n  function HubConnectionBuilder() {}\n\n  HubConnectionBuilder.prototype.configureLogging = function (logging) {\n    _Utils__WEBPACK_IMPORTED_MODULE_6__[\"Arg\"].isRequired(logging, \"logging\");\n\n    if (isLogger(logging)) {\n      this.logger = logging;\n    } else if (typeof logging === \"string\") {\n      var logLevel = parseLogLevel(logging);\n      this.logger = new _Utils__WEBPACK_IMPORTED_MODULE_6__[\"ConsoleLogger\"](logLevel);\n    } else {\n      this.logger = new _Utils__WEBPACK_IMPORTED_MODULE_6__[\"ConsoleLogger\"](logging);\n    }\n\n    return this;\n  };\n\n  HubConnectionBuilder.prototype.withUrl = function (url, transportTypeOrOptions) {\n    _Utils__WEBPACK_IMPORTED_MODULE_6__[\"Arg\"].isRequired(url, \"url\");\n    _Utils__WEBPACK_IMPORTED_MODULE_6__[\"Arg\"].isNotEmpty(url, \"url\");\n    this.url = url; // Flow-typing knows where it's at. Since HttpTransportType is a number and IHttpConnectionOptions is guaranteed\n    // to be an object, we know (as does TypeScript) this comparison is all we need to figure out which overload was called.\n\n    if (typeof transportTypeOrOptions === \"object\") {\n      this.httpConnectionOptions = __assign({}, this.httpConnectionOptions, transportTypeOrOptions);\n    } else {\n      this.httpConnectionOptions = __assign({}, this.httpConnectionOptions, {\n        transport: transportTypeOrOptions\n      });\n    }\n\n    return this;\n  };\n  /** Configures the {@link @microsoft/signalr.HubConnection} to use the specified Hub Protocol.\r\n   *\r\n   * @param {IHubProtocol} protocol The {@link @microsoft/signalr.IHubProtocol} implementation to use.\r\n   */\n\n\n  HubConnectionBuilder.prototype.withHubProtocol = function (protocol) {\n    _Utils__WEBPACK_IMPORTED_MODULE_6__[\"Arg\"].isRequired(protocol, \"protocol\");\n    this.protocol = protocol;\n    return this;\n  };\n\n  HubConnectionBuilder.prototype.withAutomaticReconnect = function (retryDelaysOrReconnectPolicy) {\n    if (this.reconnectPolicy) {\n      throw new Error(\"A reconnectPolicy has already been set.\");\n    }\n\n    if (!retryDelaysOrReconnectPolicy) {\n      this.reconnectPolicy = new _DefaultReconnectPolicy__WEBPACK_IMPORTED_MODULE_0__[\"DefaultReconnectPolicy\"]();\n    } else if (Array.isArray(retryDelaysOrReconnectPolicy)) {\n      this.reconnectPolicy = new _DefaultReconnectPolicy__WEBPACK_IMPORTED_MODULE_0__[\"DefaultReconnectPolicy\"](retryDelaysOrReconnectPolicy);\n    } else {\n      this.reconnectPolicy = retryDelaysOrReconnectPolicy;\n    }\n\n    return this;\n  };\n  /** Creates a {@link @microsoft/signalr.HubConnection} from the configuration options specified in this builder.\r\n   *\r\n   * @returns {HubConnection} The configured {@link @microsoft/signalr.HubConnection}.\r\n   */\n\n\n  HubConnectionBuilder.prototype.build = function () {\n    // If httpConnectionOptions has a logger, use it. Otherwise, override it with the one\n    // provided to configureLogger\n    var httpConnectionOptions = this.httpConnectionOptions || {}; // If it's 'null', the user **explicitly** asked for null, don't mess with it.\n\n    if (httpConnectionOptions.logger === undefined) {\n      // If our logger is undefined or null, that's OK, the HttpConnection constructor will handle it.\n      httpConnectionOptions.logger = this.logger;\n    } // Now create the connection\n\n\n    if (!this.url) {\n      throw new Error(\"The 'HubConnectionBuilder.withUrl' method must be called before building the connection.\");\n    }\n\n    var connection = new _HttpConnection__WEBPACK_IMPORTED_MODULE_1__[\"HttpConnection\"](this.url, httpConnectionOptions);\n    return _HubConnection__WEBPACK_IMPORTED_MODULE_2__[\"HubConnection\"].create(connection, this.logger || _Loggers__WEBPACK_IMPORTED_MODULE_5__[\"NullLogger\"].instance, this.protocol || new _JsonHubProtocol__WEBPACK_IMPORTED_MODULE_4__[\"JsonHubProtocol\"](), this.reconnectPolicy);\n  };\n\n  return HubConnectionBuilder;\n}();\n\n\n\nfunction isLogger(logger) {\n  return logger.log !== undefined;\n}\n\n//# sourceURL=webpack:///./node_modules/@microsoft/signalr/dist/esm/HubConnectionBuilder.js?");

/***/ }),

/***/ "v3Fn":
/*!*************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/Loggers.js ***!
  \*************************************************************/
/*! exports provided: NullLogger */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NullLogger\", function() { return NullLogger; });\n// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\n\n/** A logger that does nothing when log messages are sent to it. */\nvar NullLogger =\n/** @class */\nfunction () {\n  function NullLogger() {}\n  /** @inheritDoc */\n  // tslint:disable-next-line\n\n\n  NullLogger.prototype.log = function (_logLevel, _message) {};\n  /** The singleton instance of the {@link @microsoft/signalr.NullLogger}. */\n\n\n  NullLogger.instance = new NullLogger();\n  return NullLogger;\n}();\n\n\n\n//# sourceURL=webpack:///./node_modules/@microsoft/signalr/dist/esm/Loggers.js?");

/***/ }),

/***/ "z2YZ":
/*!*************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/esm/Subject.js ***!
  \*************************************************************/
/*! exports provided: Subject */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Subject\", function() { return Subject; });\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils */ \"ftFU\");\n// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\n\n/** Stream implementation to stream items to the server. */\n\nvar Subject =\n/** @class */\nfunction () {\n  function Subject() {\n    this.observers = [];\n  }\n\n  Subject.prototype.next = function (item) {\n    for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {\n      var observer = _a[_i];\n      observer.next(item);\n    }\n  };\n\n  Subject.prototype.error = function (err) {\n    for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {\n      var observer = _a[_i];\n\n      if (observer.error) {\n        observer.error(err);\n      }\n    }\n  };\n\n  Subject.prototype.complete = function () {\n    for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {\n      var observer = _a[_i];\n\n      if (observer.complete) {\n        observer.complete();\n      }\n    }\n  };\n\n  Subject.prototype.subscribe = function (observer) {\n    this.observers.push(observer);\n    return new _Utils__WEBPACK_IMPORTED_MODULE_0__[\"SubjectSubscription\"](this, observer);\n  };\n\n  return Subject;\n}();\n\n\n\n//# sourceURL=webpack:///./node_modules/@microsoft/signalr/dist/esm/Subject.js?");

/***/ })

}]);